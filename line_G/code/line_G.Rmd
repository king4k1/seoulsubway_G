---
title: "이용객 개별 승하차 데이터를 이용한 신설예정노선 수요예측: 강북횡단선을 중심으로"
author: |
  | KwangMin Son
  | Department of Statistics, SKKU
date: \today
output: pdf_document
fontsize: 10pt
incremental: true
header-includes:
   - \usepackage{kotex}
   - \usepackage{float}
editor_options: 
  chunk_output_type: console
---

```{r global_options, R.options=knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, fig.pos = 'H', fig.align='center')}
```

```{r}
## load packages
#devtools::install_github("king4k1/seoulsubway")
library(geosphere)
library(nkmap)
library(knitr)
library(maptools)
library(mapproj)
library(rgdal)
library(rgeos)
library(raster)
library(data.table)
library(randomForest)
library(glmnet)
library(ggrepel)
library(rpart)
library(seoulsubway)
library(kableExtra)
set.seed(2018710174)
#setwd(paste0(getwd(), "/line_G/code"))

pdf.options(family = "Korea1deb")
data(subway_data_DT)
API_key <- 'AIzaSyCvFJzO8nrvmospv--Mhi9XypO7PvBcZcw'
register_google(key = API_key)
data("subway_data")
data("subway_data_DT")
```


## 1. Introduction

### 1.1 현황

1. 지하철 승/하차 데이터는 공공데이터포털 내 `시간대별 승하차 인원 통계`로 제공된다.

    * 통계량으로 정보가 제공되므로 분석이 제한적임.

2. `서울특별시 대중교통 환승 버스 지하철 환승경로 조회정보`를 통해 최단경로 OPEN API가 제공되지만 다음과 같은 문제가 존재한다.
  
    * 가까운 위치의 두 역을 동일한 역으로 인식하는 문제. ex) 을지로입구역과 종각역
  
    * 분기점 또는 지선의 경우 경로가 제공되지 않음.
  
    * `서울시 교통정보 시스템`을 기반으로 하여, 버스/지하철이 결합된 알고리즘 구조이므로 지하철에 한정된 경로산출 시 문제. 

공개되어있는 지하철 데이터는 역별 개찰구를 통하여 수집되는 승/하차 인원 수의 합이다. 이는 역별 제공되는 통계량으로 이용객의 이동경로 등을 유추하기 어렵다. 또한 `서울특별시 대중교통 환승 버스 지하철 환승경로 조회정보`는 알고리즘이 가지는 오류로 인하여 잘못된 분석 결과를 초래할 것이다. 따라서 이를 이용한 데이터 분석에는 한계가 존재한다.

### 1.2 해결방안

우선 수도권 지하철 네트워크를 구축하여 환승시간, 지하철 위치정보 등 공공데이터를 활용한 지하철 최단경로 알고리즘은 `모든 지하철 이용객들은 가장 시간이 적게 걸리는 이동경로를 통하여 이동 한다.`라는 가정하에 제작한다. 이를 활용한 이용객 개별 승하차 데이터 분석을 통하여 인구흐름과 혼잡구간 등을 추정한다. 하지만 같은 `출발역-도착역`로 이동하는 이용객들의 이동경로를 최단경로로 통일함으로써 개인의 성향차이를 배제한다는 단점이 있다. 

## 2. Shortestpath function


```{r}
names(subway_data)

```

### 2.1 지하철 네트워크 구축 

역별 위치정보를 반영하기 위하여 공공데이터포털 내 "서울시 역코드로 지하철역 위치 조회"를 이용하였다. 이는 수도권 지하철역 695개역에 대한 `전철역코드`, `전철역명`, `호선`, `외부코드`, `사이버스테이션`, `X좌표`, `Y좌표`, `X좌표(WGS)` 그리고 `Y좌표(WGS)` 정보를 포함한다. 이를 이용하여 1-9호선, 경의중앙선, 분당선 등이 포함된 수도권 지하철 네트워크를 구축하였다. 그리고 지하철 내 지선(또는 분기점)의 경우, 이용시 환승이 필요하므로 독립된 노선으로 고려하였다. 따라서 총 22개의 수도권 지하철 노선이 포함된 지하철 네트워크를 구축하였다. 이는 각 노선에 해당하는 지하철 역 정보를 하나의 구성요소로 하는 리스트 형태이다. 또한 지하철 네트워크에 환승변수인 Transfer를 추가하여 다른 노선으로의 환승 가능성을 고려하였다. 아래 Table 1은 지하철 6호선 네트워크 구조의 예시이다. 특히, 디지털미디어시티 역과 같이 2개 이상의 노선과 환승이 가능한 경우를 고려하기 위하여 환승변수에 구분자를 두었다. 

```{r out.width="50%", fig.align='center', fig.pos = 'H'}
subway_data[["6"]] %>%
  mutate(lat = round(lat, 2), long= round(long, 2)) %>% 
  head() %>% 
  kable(format="latex", caption = paste("지하철 네트워크 데이터 구조 예시", '(6호선)'))
```

### 2.2 이동 간 소요시간 

이동 간 소요시간을 생각할 때, 다음 3가지를 고려한다.

1. 도로주소 시스템에서 제공되는 shape파일을 이용하여 두 지점 간 노선거리를 계산한다.

* 도로명주소 개발자센터 > 전자지도 다운로드 > 도로명주소 배경지도 http://www.juso.go.kr/addrlink/main.do (2019년 01월 11일자)

두 역 사이 거리를 측정한 후, "서울메트로. "지하철 표정속도는 34km/h이다." [1] 을 참고하여 역간 소요시간을 계산하였다. 

2. 공공데이터포털 내 제공되는 `환승역, 환승거리 및 소요시간 정보(서울교통공사 17.10 기준)`를 참고하여 환승 시 소요시간을 반영하였다. 하지만 모든 환승역에 대한 정보가 제공되지 않아 제공되지 않는 환승역은 `이세중. “환승할 때 뛰지 마세요”…서울지하철 열차 시간표 조정 (KBS NEWS),2017년 6월 20일` [2] 을 참고하였다. 

3. 환승 후 대기시간 : 지하철 배차시간 반영 


### 2.3 함수 제작

**알고리즘**

1. 출발역과 도착역의 노선이 다른 경우, 두 지점을 기준으로 공간을 제약한다. 이때 환승을 위하여 우회하는 경우를 고려해야 한다. 따라서 위경도를 기준으로 두 지점이 포함된 조금 더 넓은 공간으로 제약하였다.

2. 환승을 1회하는 경우, `Figure 3`와 같이, 공간 내 포함된 환승역을 선택하여 도착역으로의 이동경로를 정의한다.

```{r out.width="50%", fig.align='center', fig.cap = paste("공간제약기법(1회 환승)")}
knitr::include_graphics("../figure/transfer_1.png")
```

3. 환승을 2회하는 경우 `Figure 4`와 같이, 출발역과 노선이 같은 환승역을 선택하여 첫번째 환승 후보지로 정의한다. 다음으로 첫번째 환승 후보지와 도착역을 중심으로 동일한 방식을 적용한다.

```{r out.width="50%", fig.align='center', fig.cap = paste("공간제약기법(2회 환승)"),  echo=FALSE}
knitr::include_graphics("../figure/transfer_2.png")
```

4. 또한 알고리즘의 효율성을 높이기 위하여 다음과 같은 기준으로 최단 경로를 선정하였다. 

    * 출발역과 도착역의 노선이 공통되지 않은 경우, 처음 2회까지의 환승경로를 계산한다. 이는 공간을 제약한 상태이므로 처음 2회의 환승경로가 불필요하게 우회하는 경우는 제외한다.

    * 앞 단계에서 경로가 정의되지 않으면, 순차적으로 3회, 4회의 환승을 고려한 이동경로를 정의한다.

### 2.4 최단경로 함수 예시

* 종로3가역에서 혜화역으로의 최단경로 함수 결과

```{r out.width="70%", echo=FALSE, fig.pos = 'H', fig.align='center'}
shortestpath(departure = "길음", arrival = "청량리")
```

최단경로 함수의 결과는 크게 Info, Count, Time, 그리고 Path로 구성된다. Info는 이동경로에 대한 요약 정보이다. Count와 Time은 경유역 수와 소요시간에 대한 정보이며, Path는 경유하는 지하철 역에 대한 정보를 제공한다.

```{r out.width="70%", fig.pos = 'H', fig.align='center', fig.cap="길음역에서 혜화역으로의 최단경로"}
shortestpath_plot <- function (departure, arrival, google_key, zoom = zoom) 
{
    register_google(key = google_key)
    result <- shortestpath(departure, arrival, max_route=1)[[1]] %>% get_pathresult()
    Info <- result$Info
    index <- result %>% names %>% str_which("Path")
    Path <- result[[index[1]]]
    if (length(index) > 1) {
        for (i in 2:length(index)) {
            Path <- rbind(Path, result[[index[i]]])
        }
    }
    meanX <- mean(as.numeric(Path$long))
    meanY <- mean(as.numeric(Path$lat))
    g <- ggmap(get_map(c(meanX + 0.003, meanY + 0.003), zoom = zoom, maptype = "toner-lite", 
        source = "stamen")) + geom_path(data = Path, aes(x = as.numeric(long), 
        y = as.numeric(lat), col = Line, size=4)) + geom_label(data = Path %>% 
        filter(!duplicated(Name)), aes(x = as.numeric(long), 
        y = as.numeric(lat), label = Name), fill = "black", col = "white", 
        alpha = 0.5)
    return(g)
}

shortestpath_plot(departure = "길음",  arrival = "청량리", google_key = API_key, zoom = 14) + 
  scale_colour_manual(values=c( "#3F51B5", "#8BC34A", "skyblue")) + 
  theme(legend.position="none") + xlab("경도") + ylab("위도")  + scale_fill_viridis_c() + scale_color_viridis_d()
  #theme(strip.text = element_text(size=10), axis.title=element_text(size=10),
  #      legend.position = "none",
  #      axis.text = element_text(size=10))
  
#ggsave(filename="subway_path_ex.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```

위 최단경로 함수 결과 중 `Path`를 지도 위 시각화하여 이동경로에 대한 정보를 확인할 수 있다.

## 3. Data discription

### 3.1 원자료: 이용객 개별 승하차 데이터

* `서울교통공사`을 통하여 제공받음.

원자료는 카드사용객에 한정하여 서울교통공사에 속한 지하철을 이용하는 이용객들의 승차역과 하차역 그리고 이용 시간대에 대한 정보가 포함되어있다. 데이터의 구조는 다음과 같다.

```{r, fig.width = 7 , fig.height = 5 , fig.align ="center", fig.pos = 'H'}
load(file = '../data/sample_subway_data_0407.RData')
sample_subway_data_0407 %>% 
  mutate(ID = paste0('#', 1:10)) %>% 
  head() %>% 
  kable(format="latex", caption = '2018년 04년 07일의 이용객 개별 승하차 데이터 예시') %>%
  kable_styling(font_size = 7)
```

분석 시 `ID`, `운행일자`, `요일`, `승차호선명`, `승차역명`, `하차호선명`, `하차역명`, `시간대` 그리고 `승객수` 변수만을 고려하며, `시간대`는 하차 시간대를 의미한다.  `이용객 개별 승하차 데이터`는 1-8호선과 241개의 지하철 역으로 구성되며, 1호선의 경우는 서울교통공사 소속인 `서울 - 청량리` 구간만 포함한다. 

## 4. 강북횡단선(Gangbuk subway line)

```{r out.width="80%", fig.align='center', fig.cap="강북횡단선"}
load(file="../data/line_G.RData")
loc <- c(126.95, 37.59)
seoul <- ggmap(get_map(location=loc, zoom=12, maptype = "toner-lite", source = "stamen"))

seoul + 
  geom_path(aes(x=long, y=lat), col="brown", size=2, data=line_G) +
  geom_point(aes(x=long, y=lat, col=ifelse(Transfer==0, 'N', 'Y')), 
              size=2, data=line_G) + labs(col = "환승가능") +
  scale_color_manual(values=c("green", "red")) + 
  #geom_label_repel(aes(x=long, y=lat, label=Name), fill = "black", col = "white", 
  #               alpha = 0.7, data=line_G) +
  theme(strip.text = element_text(size=10), axis.title=element_text(size=10),
        legend.title = element_text(size=10), legend.text = element_text(size=10),
        axis.text = element_text(size=10)) + xlab("경도") + ylab("위도") + scale_fill_viridis_d() + scale_color_viridis_d()
  
#ggsave(filename="line_G.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```

* 2019년 2월 20일 발표한 `서울특별시 도시철도망 구축계획`에 포함(서울시. 2019)

* 강북지역의 8개의 환승역이 포함된 19개의 지하철(임시 역명) 역으로 구성됨

2019년 2월 20일 발표된 2차 서울특별시 도시철도망 구축계획에서 발표한 지역 균형발전과 철도 교통 소외지역 해소 목적으로 포함된 신규 경전철 노선이다. 이는 노선 선정 당시 지역균형발전 측면에서 가장 높은 점수를 기록하였으며 과거 추진되었으나 폐기된 '홍제-길음선'을 일부 구간 계승한다.

### 4.1 분석목적

강북횡단선이 개통된다면 지하철 최단경로가 달라지고, 사람들의 이동경로는 달라질 것이다. 또한 신설예정역이 생기게되면 새롭게 유입되는 이용객들이 생길 것이다. 따라서 역 주위정보를 통한 역별 승/하차값을 예측하여 그들의 이동경로를 추정하고 지하철 이용객 개별 승하차 데이터를 활용하여 강북횡단선의 노선수요를 확인한다. 이는 지하철 운영계획 수립 시 도움이 될 것이다. 그 이유로 지하철은 다양한 시간대에 다양한 사람들이 이용하는 대중교통이기에 운영비 관점에서 보았을 때, 차량의 탄력적인 운영을 통한 수송효율성을 높이는 것이 중요하기 때문이다.

### 4.2 시뮬레이션을 위한 강북횡단선 노선 정의

2019년 2월 20일 발표한 `서울특별시 도시철도망 구축계획`을 통해 목동~청량리를 잇는 강북횡단선 등 6개 노선 신설에 대한 계획이 공개되었다. 본 논문에서는 강북횡단선에 대하여 고려할 것이다. 우선 강북횡단선을 기존 구축한 지하철 네트워크에 추가하는 과정이 필요하다.

```{r}
load(file="../data/subway_data_G.RData")
load(file="../data/subway_data_G_DT.RData")
load(file="../data/transfer_station_G.RData")
kable(line_G, "latex")
```

위 표와 같이 8개의 환승역이 포함된 19개의 지하철 역에 대한 지하철 네트워크를 구축하였다. 이를 반영한 네트워크를 구축하여 새로운 노선이 추가되었을 때의 최단경로를 확인할 수 있다.

### 4.3 강북횡단선이 포함된 최단경로 데이터베이스 구축

```{r}
load(file="../data/line_G_simulation_data.RData")
load(file="../data/line_G_simulation_fun.RData")
```

앞 과정을 통하여 구축한 지하철 네트워크를 통하여 최단거리 자료구조를 구축하였다. 이용객 개별 승하차 데이터포함된 241개역과 서울시 내 1-8호선 외 노선 지하철역 그리고 신설예정 지하철역이 포함된 총 321개 역에 대하여 모든 경로를 포함하였다.

#### 4.3.1 최단경로 함수(강북횡단선 포함)

앞에서 설명한 지하철 최단경로 알고리즘을 반영한 최단경로 함수의 결과는 다음과 같다. 

```{r, eval=FALSE}
for(i in 1:length(subway_route_G_0411)){
  subway_route_G_0411[[i]]$Path <- subway_route_G_0411[[i]]$Path[,c("Code","Name","Line",
                                                                    "ExCode","lat","long",
                                                                    "Transfer","Dist","Time")]
  subway_route_G_0411[[i]]$Path1 <- subway_route_G_0411[[i]]$Path1[,c("Code","Name","Line",
                                                                    "ExCode","lat","long",
                                                                    "Transfer","Dist","Time")]
  subway_route_G_0411[[i]]$Path2 <- subway_route_G_0411[[i]]$Path2[,c("Code","Name","Line",
                                                                    "ExCode","lat","long",
                                                                    "Transfer","Dist","Time")]
  subway_route_G_0411[[i]]$Path3 <- subway_route_G_0411[[i]]$Path3[,c("Code","Name","Line",
                                                                    "ExCode","lat","long",
                                                                    "Transfer","Dist","Time")]
  subway_route_G_0411[[i]]$Path4 <- subway_route_G_0411[[i]]$Path4[,c("Code","Name","Line",
                                                                    "ExCode","lat","long",
                                                                    "Transfer","Dist","Time")]
  subway_route_G_0411[[i]]$Path5 <- subway_route_G_0411[[i]]$Path5[,c("Code","Name","Line",
                                                                    "ExCode","lat","long",
                                                                    "Transfer","Dist","Time")]
}
#save(file="../data/subway_route_G_0411.RData", subway_route_G_0411)
```

```{r, echo=FALSE}
shortestpath_G(depart = "길음", arrival = "청량리")
```

길음역에서 청량리역으로의 최단경로 함수의 결과에는 앞에서 정의한 최단경로 알고리즘과 동일하게 Info, Count, Time, 그리고 Path로 구성된다. 

```{r}
shortestpath_G_plot <- function (depart, arrival, google_key, zoom = zoom){
    register_google(key = google_key)
    result <- shortestpath_G(depart, arrival)
    Info <- result$Info
    index <- result %>% names %>% str_which("Path")
    Path <- result[[index[1]]]
    if (length(index) > 1) {
        for (i in 2:length(index)) {
            Path <- rbind(Path, result[[index[i]]])
        }
    }
    meanX <- mean(as.numeric(Path$long))
    meanY <- mean(as.numeric(Path$lat))
    Path_edit <- Path %>% filter(!duplicated(Name))
    g <- ggmap(get_map(c(meanX, meanY), zoom = zoom, maptype = "toner-lite", 
        source = "stamen")) +
      geom_path(data = Path_edit, aes(x = as.numeric(long), 
        y = as.numeric(lat), size=4, col="brown")) +
      geom_label(data = Path_edit, aes(x = as.numeric(long), 
        y = as.numeric(lat), label = Name), fill = "black", col = "white", 
        alpha = 0.5, hjust=ifelse(Path_edit$Name=="길음", 0.1, 0))
    return(g)
}

shortestpath_G_plot(depart = "길음", arrival = "청량리", google_key = API_key, zoom = 14) +
  scale_color_manual(values="brown") + 
theme(strip.text = element_text(size=10), axis.title=element_text(size=10),
        #legend.title = element_text(size=10), legend.text = element_text(size=10),
      legend.position = "none", axis.text = element_text(size=10))  +
  xlab("경도") + ylab("위도") + scale_fill_viridis_c()
#ggsave(filename="line_G_path.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```

위 그림을 통하여 기존 지하철 경로에서는 길음(4)에서 청량리(1)로 이동 시 환승이 필요하였지만, 환승없이 빠르게 이동이 가능한 것을 확인할 수 있다. 


#### 4.3.2 최단경로 자료구조 제작(강북횡단선 포함)

우선 `출발역 -> 도착역`의 한정된 정보만 제공되는 데이터를 이용하여 분석목적에 적합한 형태로 재정의하는 과정이 필요하다. 이는 이동 간 경유하는 모든 구간에 대한 정보를 포함한 새로운 데이터 구조를 말한다. 예를 들어서 강북횡단선을 이용한다면, 길음역에서 출발하여 청량리역에 도착하는 경우, `길음-종암사거리`, `종암사거리-월곡`, `월곡-홍릉` 그리고 `홍릉-청량리`로 4개의 구간을 경유할 것이다. 이와 같은 방식으로 모든 지하철 경로의 이동 정보에 대한 데이터를 포함한 자료구조를 제작하였다. 자료구조 제작시, 321개의 출발역과 도착역 쌍에 대한 321x321 행렬구조에서 상삼각행렬에 해당하는 최단경로를 모두 구한 후, `set`의 순서와 from과 to를 바꾸어 하삼각행렬에 해당하는 경우의 경로쌍을 제작하였다. 

```{r}
shortestpath_db_G <- readRDS(file="../data/shortestpath_db_G0610.RDS")
```

## 5. 강북횡단선에 대한 수요 예측

본 연구에서는 신규노선인 강북횡단선에 대한 수요를 다음 2가지로 예측하려고 한다.

  1. 역 주변정보를 이용한 승/하차 인원 예측
  
  2. 이용객 개별 승하차 데이터와 최단경로 데이터베이스를 이용한 이동경로 수요예측

신설예정노선에 포함된 신설예정역이 생기면, 새로운 이용객들이 유입될 것이다. 따라서 이를 고려하기 위하여 역 주위정보를 이용하여 승하차 인원을 예측한다. 승하차 인원 예측시, 강북횡단선 내 포함된 지하철 역과 경로가 제공되지 않는 노선(1-8호선 이외)에 포함된 지하철역들도 포함한다. 승하차 인원을 통하여 추정한 새로운 이동경로와 이용객 개별 승하차 데이터로 이동경로 데이터셋을 만들고, 강북횡단선이 포함된 최단경로 자료구조를 활용하여 수요를 확인한다. 이를 통하여 실질적으로 강북횡단선을 이용하는 이용객들의 수를 확인할 수 있다.

### 5.1 역 주위정보 수집을 통한 자료구축

강북횡단선을 포함한 지하철 네트워크 내 포함된 지하철 역은 총 479개이다. 이 중 서울 지역에 해당하는 302개역만을 선택하여 역 주변정보를 확인한다. 역 주변정보에는 반경 500m를 기준으로 한 집계구 정보와 시설 정보 등이 있다.

```{r}
station_seoul <- subway_data_G_DT %>% 
  dplyr::select(Name, lat, long) %>% 
  filter(!duplicated(Name))

get_geocode_kakao <- function(address_lon, address_lat, daum_apikey) {
  base_url <- "https://dapi.kakao.com/v2/local/geo/coord2regioncode.json"
  parsed_page <- GET(paste0(base_url,
                            '?x=', address_lon,
                            "&y=", address_lat,
                            '&input_coord=WGS84'),
                     add_headers('Authorization' = paste0("KakaoAK ",daum_apikey)))
  
  
  # json format을 list 형으로 변환
  parsed_json <- content(parsed_page, "text")[[1]]
  response <- fromJSON(parsed_json)[[2]]
  result <- response %>% as_tibble
  return(result)
}
daum_apikey <- '4febb0939357ec9fee82262801d5314b'

index <- rep(NA, 479)
for(i in 1:479){
  result <- get_geocode_kakao(station_seoul$long[i], station_seoul$lat[i], daum_apikey)
  index[i] <- result$address_name[1]
}
station_seoul$address <- index
station_seoul <- station_seoul[str_detect(index, "서울"),]
```

우선 역별 주위 정보 중 집계구 정보를 반영하기 위하여는 기준이 필요하다. 이때, 2017년 10월 기준 행정구역 자료를 이용하였다. 집계구 정보에는 공통적으로 `행정구역분류`가 포함되어져 있으므로 이를 기준으로 데이터를 제작한다.

```{r merge_rule, echo=FALSE, message=FALSE}
# 행정구역 통합 기준 셋
# 행정구역 코드는 "AD_CD"로 통일
gun_gu_code <- fread("../data/gungu_201710.csv", encoding = "UTF-8")
name <- gun_gu_code[2,-11]
gun_gu_code <- gun_gu_code[c(-1,-2),-11]
colnames(gun_gu_code) <- as.character(name)
head(gun_gu_code)

head(gun_gu_code) %>% kable("latex")

names(gun_gu_code)[6] <- "AD_CD"
gun_gu_code <- gun_gu_code[str_detect(gun_gu_code$AD_CD, "^11"),]
```

#### 5.1.1 [국가공간정보포털 내 인구주택총조사 통계_인구부문(2016)](http://data.nsdi.go.kr/dataset/20171206ds00009/resource/48c14840-4aca-4779-aed0-6e218404509f?inner_span=True)

| 변수명      | 설명             |
|-------------|------------------|
| youngage    | 0~10세 인구      |
| teenage     | 10~20대 인구     |
| middleage1  | 20~30대 인구     |
| middleage2  | 40~50대 인구     |
| oldage      | 60세 이상 인구   |

```{r population, echo=FALSE, message=FALSE, warning=FALSE}
tot_ppl <- fread(file="../Z_SOP_OA/tot_ppl_2015.txt", sep="^")
tot_ppl <- tot_ppl %>% 
  filter(str_detect(tot_oa_cd, "^11")) %>%
  rename(tot_pop = value) %>%
  dplyr::select(-base_year, -item)

ppl <- fread(file="../Z_SOP_OA/ppl_2015.txt", sep="^")
ppl <- ppl %>% 
  filter(str_detect(tot_oa_cd, "^11")) %>% 
  dplyr::select(-base_year) %>% 
  spread(item, value) %>% 
  mutate_all(as.numeric)
ppl[is.na(ppl)] <- 0
ppl$tot_oa_cd <- as.character(ppl$tot_oa_cd)
tot_ppl$tot_oa_cd <- as.character(tot_ppl$tot_oa_cd)
ppl_var <- left_join(ppl, tot_ppl)
ppl_var_handle <- ppl_var %>% 
  mutate(youngage = in_age_001 + in_age_002,
         teenage = in_age_003 + in_age_004,
         middle1age = in_age_005 + in_age_006 + in_age_007 + in_age_008,
         middle2age = in_age_009 + in_age_010 
         + in_age_011 + in_age_012 + in_age_013,
         oldage = in_age_014 + in_age_015 
         + in_age_016 + in_age_017 + in_age_018 
         + in_age_019 + in_age_020 + in_age_021) %>%
  dplyr::select(tot_oa_cd, ends_with("age"), tot_pop) %>% 
  as_tibble

ppl_var_handle$tot_oa_cd <- str_sub(ppl_var_handle$tot_oa_cd, 1, 7)
ppl_var_handle <- ppl_var_handle %>%
  group_by(tot_oa_cd) %>% 
  summarise(youngage = sum(youngage),
            teenage = sum(teenage),
            middleage1 = sum(middle1age),
            middleage2 = sum(middle2age),
            oldage = sum(oldage)) %>% 
  rename(AD_CD = tot_oa_cd)

glimpse(ppl_var_handle)
```

지하철 승하차 인원의 수를 예측하는 데 있어서 가장 중요한 것은 지하철 역 주위에 거주하고 있는 인구 수 일 것이다. 이는 실질적으로 지하철을 이용할 가능성이 있는 인원의 수이기 때문이다. 집계구 자료에는 행정구역분류 별 5세를 기준으로 인구 수에 대한 수치가 반영되어져 있다. 이를 위 표와 같이 총 5개의 범주로 나누었다. 

#### 5.1.2 [국가공간정보포털 내 인구주택총조사 통계_사업체부문(2016)](http://data.nsdi.go.kr/dataset/20171206ds00006/resource/4f363f8b-d94b-4c66-a633-b5ea1989bf9d)

| 사업체 코드        | 분류                                       |
|--------------------|--------------------------------------------|
| cp_bnu_003         | 제조업 수                                  |
| cp_bnu_006         | 건설업 수                                  |
| cp_bnu_007         | 도소매업 수                                |
| cp_bnu_008         | 운수업 수                                  |
| cp_bnu_009         | 숙박 및 음식점업 수                        |
| cp_bnu_010         | 출판 영상, 방송통신 및 정보서비스업 수     |
| cp_bnu_011         | 금융 및 보험업 수                          |
| cp_bnu_012         | 부동산업 및 임대업 수                      |
| cp_bnu_013         | 전문 과학 및 기술서비스업 수               |
| cp_bnu_014         | 사업시설관리 및 사업지원 서비스업 수       |
| cp_bnu_015         | 공공행정, 국방 및 사회보장 행정 수         |
| cp_bnu_016         | 교육서비스업 수                            |
| cp_bnu_017         | 보건업 및 사회복지 서비스업 수             |
| cp_bnu_018         | 예술, 스포츠 및 여가관련 서비스업 수       |
| cp_bnu_019         | 협회 및 단체, 수리 및 기타 개인서비스업 수 |

또한 사업체 수 자료를 하나의 변수로 포함하였다. 예를 들어서 숙박 및 음식점 수가 많은 지역은 사람이 많이 거주하거나, 많이 몰리는 유흥지역일 것이다. 그리고, 각 사업체 수가 많이 밀집한 지역은 주요 근무지역으로써, 출퇴근시간대에 승/하차 인원 수가 급증하는 형태일 것이다. 변수를 반영하는 과정에서 서울 지역에는 농업, 임업 및 어업(001, 광업(002) 그리고 전기, 가스, 증기 및 수도사업(004) 사업체가 존재하지 않아 제거하였다. 또한 하수, 폐기물 처리, 원료재생 및 환경복원업(005) 사업체의 경우 목동과 가양동 2곳에만 존재하여 제외하였다.

```{r company report, echo=FALSE, message=FALSE, warning=FALSE}
company <- fread(file="../Z_SOP_OA/company_2015.txt", sep="^")
company <- company %>% 
  filter(str_detect(tot_oa_cd, "^11")) %>%
  dplyr::select(-base_year) %>%
  mutate_at(.var = 'value' ,as.numeric) 
company[is.na(company)] <- 0

company$tot_oa_cd <- str_sub(company$tot_oa_cd, 1, 7)
company_handle <- company %>% 
  group_by(tot_oa_cd, item) %>%
  summarise(value=sum(value)) %>%
  spread(item, value) %>%
  rename(AD_CD = tot_oa_cd)
company_handle[is.na(company_handle)] <- 0


### 농업, 임업 및 어업 그리고 광업의 경우 서울 내 존재하지 않음
### 전기, 가스, 증기 및 수도사업의 경우 포함
### 하수, 폐기물 처리, 원료재생 및 환경복원업의 경우 2곳에서만 발견(목동, 가양동) 제외
company_handle$cp_bnu_001 <- NULL
company_handle$cp_bnu_002 <- NULL
company_handle$cp_bnu_004 <- NULL
company_handle$cp_bnu_005 <- NULL
company_handle$cp_bnu_999 <- NULL

glimpse(company_handle)
```


#### 5.1.3 [국가공간정보포털 내 인구주택총조사 통계_가구부분(2016)](http://data.nsdi.go.kr/dataset/20171206ds00007/resource/88154502-eaeb-4fed-b82c-359d3ad0ed27)

| 변수명        | 설명                       |
|---------------|----------------------------|
| avg_gagu_ppl  | 평균 가구원수              |
| gagu_gen1     | 1세대 가구 수              |
| gagu_gen2     | 2세대 가구 수              |
| gagu_gen3     | 3세대 가구 수              |
| gagu_alone    | 1인 가구 수                |
| gagu_etc      | 4세대 가구 수 및 비혈연가구 수  |

```{r gagu, echo=FALSE, warning=FALSE, message=FALSE, warning=FALSE}
gagu <- fread(file="../Z_SOP_OA/gagu_tot_2015.txt", sep="^")
gagu <- gagu %>% 
  filter(str_detect(tot_oa_cd, "^11")) %>%
  dplyr::select(-base_year) %>% 
  spread(item, value) %>%
  rename(tot_gagu = to_ga_001,
         avg_gagu_ppl = to_ga_002)

gagu$tot_oa_cd <- str_sub(gagu$tot_oa_cd, 1, 7)
gagu_handle <- gagu %>%
  group_by(tot_oa_cd) %>% 
  summarise(tot_gagu = sum(tot_gagu),
            avg_gagu_ppl = mean(avg_gagu_ppl)) %>% 
  rename(AD_CD = tot_oa_cd)

gagu_contents <- fread(file="../Z_SOP_OA/gagu_guseong_2015.txt", sep="^")
gagu_contents <- gagu_contents %>% 
  filter(str_detect(tot_oa_cd, "^11")) %>%
  dplyr::select(-base_year) %>% 
  spread(item, value) %>%
  mutate_all(as.numeric) %>%
  rename(gagu_gen1 = ga_sd_001,
         gagu_gen2 = ga_sd_002,
         gagu_gen3 = ga_sd_003,
         gagu_alone = ga_sd_005)
gagu_contents[is.na(gagu_contents)] <- 0
gagu_contents <- gagu_contents %>%
  group_by(tot_oa_cd) %>% 
  mutate(gagu_etc = sum(ga_sd_004, ga_sd_006, ga_sd_999)) %>% 
  dplyr::select(-ga_sd_004, -ga_sd_006, -ga_sd_999) %>%
  ungroup %>%
  mutate_at(.var='tot_oa_cd', as.character) %>% 
  as_tibble 
gagu_contents$tot_oa_cd <- str_sub(gagu_contents$tot_oa_cd, 1, 7)
gagu_contents <- gagu_contents %>%
  group_by(tot_oa_cd) %>%
  summarise(gagu_gen1 = sum(gagu_gen1),
            gagu_gen2 = sum(gagu_gen2),
            gagu_gen3 = sum(gagu_gen3),
            gagu_alone = sum(gagu_alone),
            gagu_etc = sum(gagu_etc)) %>% 
  rename(AD_CD = tot_oa_cd)

gagu_merge <- left_join(gagu_handle, gagu_contents, by="AD_CD")

gagu_merge$tot_gagu <- NULL

glimpse(gagu_merge)
```


#### 5.1.4 [다음API](https://developers.kakao.com/docs/restapi/tool)를 이용하여 6가지 변수 선정(`대형마트`, `학교`, `학원`, `문화시설`, `관광명소`, `병원`)

서울시 내 지하철 302개 역에 대하여 반경 500m 이내 `대형마트`, `학교`, `학원`, `문화시설`, `관광명소`, `병원` 시설 수를 변수로 추가하였다. 이는 다음 API를 통하여 구하였다.

```{r use daumapi to get subwaystation nearby info, echo=FALSE}
daum_apikey <- '4febb0939357ec9fee82262801d5314b'

localdata_category <- function(address_lon, address_lat, radius_m, category_code) {
  base_url <- "https://dapi.kakao.com/v2/local/search/category.json"
  parsed_page <- GET(URLencode(paste(base_url,
                                     '?category_group_code=', category_code,
                                     "&y=", address_lat, '&x=', address_lon,
                                     '&size=1&page=1&radius=', radius_m, 
                                     sep='')),
                     add_headers("Authorization" = paste("KakaoAK ",
                                                         daum_apikey, sep='')))
  
  # json format을 list 형으로 변환
  parsed_json <- content(parsed_page)
  return(parsed_json$meta$total_count)
}

### category_code 종류
# MT1(대형마트), CS2(편의점), PS3(어린이집, 유치원), SC4(학교), AC5(학원)
# PK6(주차장), OL7(주유소, 충전소), SW8(지하철역), BK9(은행)
# CT1(문화시설), AT4(관광명소), PO3(공공기관), AG2(중개업소)
# AD5(숙박), FD6(음식점), CE7(카페), HP8(병원), PM9(약국)
### 1차 상권은 사업장 이용고객의 60% - 70%를 포함하는 범위를 말하며, 점포인 경우는 약 500m 반경 이내의 지점을 말한다.  (도보 5분 거리) http://cfile219.uf.daum.net/attach/175F11304CA163B765B611
### 1차 상권은 사업장 이용고객의 60% - 70%를 포함하는 범위를 말하며, 
# 점포인 경우는 약 500m 반경 이내의 지점을 말한다.  (도보 5분 거리)
# http://cfile219.uf.daum.net/attach/175F11304CA163B765B611

#(`대형마트`, `학교`, `학원`, `문화시설`, `관광명소`, `병원`)
market_info <- list()
get_crawling_list <- c("MT1", "SC4", 'AC5', "CT1", "AT4", "HP8")
for(i in 1:6){
  station_seoul[,get_crawling_list[i]] <- 0
  for(j in 1:302){
  station_seoul[j,get_crawling_list[i]] <- 
    localdata_category(as.numeric(station_seoul$long[j]),
                       as.numeric(station_seoul$lat[j]), 
                       radius_m = 500, 
                       category_code = get_crawling_list[i])
  }
}
head(station_seoul)

colnames(station_seoul) <- c("station", "lat", "long", 
                             "address", "market_store", "school",
                             "academy", "cultural_facility",
                             "attraction","hospital")
```

```{r}
station_seoul_daum <- fread("../data/station_seoul_daum.csv", encoding = "UTF-8")
glimpse(station_seoul_daum)
```

#### 5.1.5 버스정류장 위치데이터 이용 반경 500m 이내 버스정류장 수

지하철 승/하차 인원 수는 역 주위 버스정류장의 수와 밀접한 관련이 있다. 왜냐하면 버스와 지하철 간 환승시스템으로 인하여 지하철과 버스를 같이 이용하는 경우가 많기 때문이다. 버스정류장 위치데이터는 공공데이터 포털에 요청하여 얻을 수 있었다. 이를 이용하여 수도권 내 11000여 곳의 버스정류장과 302개의 지하철역 사이의 거리행렬 구하여 반경 500m 이내의 버스정류장 수를 확인하였다. 

```{r use dist matrix to get bus station count, echo=FALSE, eval=FALSE}
bus_station <- fread(file="../data/bus_station_longlat.csv", encoding="UTF-8")
bus_station %>% head() %>% kable("latex")

bus_station <- bus_station %>% 
  dplyr::select(정류소명, X좌표, Y좌표) %>%
  rename(long = X좌표, lat = Y좌표)

# 11069 x 222 매트릭스 제작 후 거리행렬 생성
dist_mat <- data.frame(matrix(0, 11069, 302))

for(i in 1:11069){
  for(j in 1:302){
    dist_mat[i,j] <-
      distHaversine(as.numeric(bus_station[i,c("long", "lat")]),
                    as.numeric(station_seoul[j,c("long","lat")]))
  }
}

# 역 기준 반경 500m 이내 지점 수 확인
count <- c()
for(i in 1:302){
  count[i] <- sum(dist_mat[,i]<=500)
}

station_seoul$bus_stop <- count

# 환승 가능한 노선 수에 대한 변수 <- 지하철 승하차와 관련 없음.
#tot_station_longlat$transfer_available <- 0
#data("transfer_station")
#for(i in 1:81){
#transfer_station$T_count[i] <-
#length(str_split(transfer_station$Transfer, "[|]")[[i]])
#}

#tot_station_longlat$transfer_available[which(tot_station_longlat$station%in%transfer_station$Name)] <- transfer_station$T_count
head(station_seoul)
```

```{r}
station_seoul_bus <- fread("../data/station_seoul_bus.csv", encoding="UTF-8")
glimpse(station_seoul_bus)
```


#### 5.1.6 지하철 반경 500m 이내 용도지역 점수

용도지역이란 '토지의 이용 및 건축물의 용도,  건폐율, 용적률, 높이 등을 제한함으로써 토지를 경제적  효율적으로 이용하고 공공복리의 증진을 도모하기 위하여 서로 중복되지 아니하게 도시관리계획으로 결정하는 지역`을 말한다. 용도지역 종류는 서울시와 같은 도시지역에서는 크게 주거지역, 상업지역, 공업지역, 녹지지역으로 구분하고 있으며, 개념은 다음과 같다.

- 주거지역 : 거주의 안녕과 건전한 생활환경의 보호를 위하여 필요한 지역 
- 상업지역 : 상업 그 밖의 업무의 편익증인을 위하여 필요한 지역
- 공업지역 : 공업의 편익증진을 위하여 필요한 지역
- 녹지지역 : 자역환경, 농지 및 산림의 보호, 보건위생, 보안과 도시의 무질서한 확산을 방지하기 위하여 녹지의 보전이 필요한 지역

이를 참고하여 서울시 용도지역 shape 파일 내 용도지역 구분으로 준주거지역, 주거지역, 상업지역, 공업지역, 자연녹지지역, 기타사업, 도시계획 시설, 용도지역, 토지구획정리사업와 같이 구분되어 있다. 하지만 대부분의 지하철 역 근처에 녹지지역이 존재하지 않으므로 국토 용도지역은 크게 상업, 주거, 공업, 이외기타 4가지로 구성한다. [서울시 도시계획과 토지이용규제정보서비스](http://luris.molit.go.kr/web/actreg/lawlanguage/WebLawLanguageView.jsp?termsNo=00420&termsIndexNm=) 또한 준주거지역이란 '주거기능을 위주로 이를 지원하는 일부 상업기능 및 업무기능을 보완하기 위하여 필요한 지역'으로 주거지역과 상업지역을 모두 고려하기 위하여 새로운 용도지역으로 구분한 후 주거지역과 상업지역에 점수를 동일하게 부여하였다.
 
  1. 서울시 shape파일 내부에 100m 간격으로 grid를 생성. 

  2. 302개의 지하철역에 대하여 반경 500m 내의 속하는 grid point를 확인.

  3. 용도점수는 역에 가까운 용도일 수록 높은 점수를 부여하기 위하여 gaussian kernel을 통해 weight 계산
    
    $gaussian \space kernel : \space exp(-\frac{1}{\sigma} \times (origin - grid)^2)$

  4. 용도별 가중합 점수 계산
  
```{r usezoning, fig.width=5, fig.height=3}
usezoning <- readOGR(dsn="../data", layer="seoul_usezoning",
                     encoding = "UTF-8", verbose = FALSE)

## set cellsize : set 100m(almost) distance for grid
cs <- c(0.00092, 0.0009)
grdpts <- makegrid(usezoning, cellsize = cs)
spgrd <- SpatialPoints(grdpts, proj4string = CRS(proj4string(usezoning)))
spgrdWithin <- SpatialPixels(spgrd[usezoning,])

## match with shp data file
inusz <- over(spgrdWithin, usezoning)

## make dataset
gridpoint <- spgrdWithin@coords
gridpoint_usz <- cbind(gridpoint, as.character(inusz$LABEL))
gridpoint_usz <- as.data.frame(gridpoint_usz)
colnames(gridpoint_usz) <- c("long", "lat", "usz")

## make rules about category about usezoning
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$usz, "준주거"),
                                 "준주거", as.character(gridpoint_usz$usz))
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$type, "주거"),
                                 "주거", as.character(gridpoint_usz$type))
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$type, "상업"),
                                 "상업", as.character(gridpoint_usz$type))
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$type, "공업"),
                                 "공업", as.character(gridpoint_usz$type))
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$type, "자연녹지지역"),
                                 "기타", as.character(gridpoint_usz$type))
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$type, "기타사업"),
                                 "기타", as.character(gridpoint_usz$type))
gridpoint_usz$type <- ifelse(str_detect(gridpoint_usz$type, "도시계획 시설|용도지역|토지구획정리사업"), "기타", as.character(gridpoint_usz$type))
## check ratio about usezoning type
# table(gridpoint_usz$type)

## preprocessing
gridpoint_usz$long <- as.character(gridpoint_usz$long)
gridpoint_usz$lat <- as.character(gridpoint_usz$lat)
gridpoint_usz$usz <- as.character(gridpoint_usz$usz)

# edit gausskernel in KRLS pack.
gausskernel_Haversine <- function (origin, mat = NULL, sigma = NULL) {
    return(exp(-1 * as.matrix(distHaversine(origin, mat)^2)/sigma))
}

find_usezoning_circle <- function(long_rec, lat_rec, sd_select){
  longcut <- gridpoint_usz[which(gridpoint_usz$long <= long_rec + 0.00566 &
                                 gridpoint_usz$long >= long_rec -0.00566),]
  ### long 기준으로 0.00566정도는 좌우로 약 500m 거리의 지점을 의미합니다.
  latcut <- longcut[which(longcut$lat <= lat_rec + 0.00449 &
                          longcut$lat >= lat_rec - 0.00449),]
  ### lat 기준으로 0.00449정도는 상하로 약 500m 거리의 지점을 의미합니다.
  ### 즉, 역 기준으로 1km의 정사각형 구간으로 공간을 한정합니다.
  ### 이후 distHaversine 수식을 이용하여 500m 내에 포함되는 spot만 간추려냅니다.
  dist <- c()
  for(i in 1:nrow(latcut)){
    dist[i] <- distHaversine(c(as.numeric(latcut$long[i]),
                               as.numeric(latcut$lat[i])),
                               c(long_rec, lat_rec))
  }
  latcut_result <- latcut[which(dist <= 500 & dist !=0),]
  latcut_result$dist <- dist[which(dist <= 500 & dist !=0)]
  if(length(dist)==1){
    latcut_result <- latcut
  }
  latcut_result$weight_sd <- 
    gausskernel_Haversine(origin = c(long_rec, lat_rec),
                          mat = data.matrix(latcut_result[,c("long","lat")]),
                          sigma = sd_select^2)[,1]
  if(length(dist)==1){
    latcut_result$weight_sd <- 0
  }
  result <- latcut_result %>% 
    group_by(type) %>% 
    summarise(ratio=sum(weight_sd)) %>% spread(type, ratio)
  gg <- ggplot(latcut_result, 
               aes(x=long, y=lat, col = type, size=weight_sd)) + 
    geom_point() + coord_fixed() + 
    scale_x_discrete(breaks=c(as.numeric(seq(min(latcut_result$long), 
                                  max(latcut_result$long), 0.0002)))) + 
    scale_y_discrete(breaks=c(as.numeric(seq(min(latcut_result$lat), 
                                  max(latcut_result$lat), 0.0002)))) +
    theme_bw()

  n_point <- nrow(latcut_result)
  result_list <- list(table = result, n = n_point, plot = gg)
  result_list
}

```

```{r, echo=FALSE, fig.width=5, fig.height=3, fig.align='center'}
station_seoul[21,]
find_usezoning_circle(long_rec = as.numeric(station_seoul$long[21]),
                      lat_rec = as.numeric(station_seoul$lat[21]),
                      sd_select = 500) 

long_rec = as.numeric(station_seoul$long[21])
lat_rec = as.numeric(station_seoul$lat[21])
sd_select <- 500
longcut <- gridpoint_usz[which(gridpoint_usz$long <= long_rec + 0.00566 &
                               gridpoint_usz$long >= long_rec -0.00566),]
### long 기준으로 0.00566정도는 좌우로 약 500m 거리의 지점을 의미합니다.
latcut <- longcut[which(longcut$lat <= lat_rec + 0.00449 &
                        longcut$lat >= lat_rec - 0.00449),]
### lat 기준으로 0.00449정도는 상하로 약 500m 거리의 지점을 의미합니다.
### 즉, 역 기준으로 1km의 정사각형 구간으로 공간을 한정합니다.
### 이후 distHaversine 수식을 이용하여 500m 내에 포함되는 spot만 간추려냅니다.
dist <- c()
for(i in 1:nrow(latcut)){
  dist[i] <- distHaversine(c(as.numeric(latcut$long[i]),
                             as.numeric(latcut$lat[i])),
                             c(long_rec, lat_rec))
}
latcut_result <- latcut[which(dist <= 500 & dist !=0),]
latcut_result$dist <- dist[which(dist <= 500 & dist !=0)]
if(length(dist)==1){
  latcut_result <- latcut
}
latcut_result$weight_sd <- 
  gausskernel_Haversine(origin = c(long_rec, lat_rec),
                        mat = data.matrix(latcut_result[,c("long","lat")]),
                        sigma = sd_select^2)[,1]
if(length(dist)==1){
  latcut_result$weight_sd <- 0
}

latcut_result <- latcut_result %>%
  mutate(long = as.numeric(long), lat = as.numeric(lat)) %>% 
  mutate(type=ifelse(type=="etc", "기타", type))

seoulstation_fty <- usezoning %>% fortify() %>% 
  filter(long<=126.979, long > 126.965, lat <= 37.56, lat >37.548)  

ggplot() + 
  geom_polygon(aes(x=long, y=lat, group=group), fill = "white", 
               col="black", alpha= 0.2, data=seoulstation_fty) + 
  geom_point(data=latcut_result, aes(x=long, y=lat, col=type, size=weight_sd)) + 
  geom_point(aes(x=126.9726, y=37.55465), size=3, col="red") +
  theme_bw() +xlab("경도") + ylab("위도") + labs(col="용도지역", size="가중치") +
  scale_fill_viridis_c() + scale_color_viridis_d() + coord_map()

#ggsave(filename="usz_seoul.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```

```{r echo=FALSE, eval=FALSE}
station_seoul$usz_sang <- 0
station_seoul$usz_ju <- 0
station_seoul$usz_etc <- 0
station_seoul$usz_gong <- 0

for(i in 1:302){
  usz_result <- tryCatch(find_usezoning_circle(long_rec = as.numeric(station_seoul$long[i]),
                                      lat_rec = as.numeric(station_seoul$lat[i]),
                                      sd_select = 500)$table,
                         error = function(e) {usz_result = as_tibble(data.frame("상업"=0))})
  n <- ncol(usz_result)
  for(j in 1:n){
    if(names(usz_result[j])=="공업"){
      station_seoul$usz_gong[i] <- usz_result$공업
    }else if(names(usz_result[j])=="상업"){
      station_seoul$usz_sang[i] <- usz_result$상업
    }else if(names(usz_result[j])=="주거"){
      station_seoul$usz_ju[i] <- usz_result$주거
    }else if(names(usz_result[j])=="etc"){
      station_seoul$usz_etc[i] <- usz_result$etc
    }else if(names(usz_result[j])=="준주거"){
      station_seoul$usz_ju[i] <- station_seoul$usz_ju[i] + usz_result$준주거/2
      station_seoul$usz_sang[i] <- station_seoul$usz_sang[i] + usz_result$준주거/2
    }
  }
}
#write_csv(path="../data/station_seoul.csv", station_seoul)
```

```{r, include=FALSE}
station_seoul <- fread("../data/station_seoul.csv", encoding="UTF-8")
```

```{r merge all dataset, echo=FALSE, message=FALSE, warning=FALSE}
gungu_info <- gagu_merge %>% 
  left_join(company_handle) %>% 
  left_join(ppl_var_handle) %>%
  left_join(gun_gu_code)
```

#### 5.1.7 지하철 역별 노선 수

하나의 지하철역에 대하여 2개 이상의 노선이 이용가능한 환승역의 경우, 외부인구유입이 더 많을 것이다. 따라서 이를 고려하기 위하여 모든 지하철 역에 대하여 이용가능한 노선의 수를 반영하였다.

#### 5.1.8 지하철 역 별 주위 정보 반영방법

서울시 행정구역 shape 파일을 이용하여 앞과 동일하게 100m 간격으로 점을 찍는 과정을 통해 grid를 생성하였다. 그 후 302개의 역에 대하여 반경 500m에 속하는 행정구역을 확인하고, 해당 행정구역들의 grid의 수를 이용하여 가중평균을 계산하였다. 

```{r 500m radius address mean result, fig.width=5, fig.height=3}
seoul <- readOGR(dsn="../seoulshp", layer="TL_SCCO_EMD",
                 encoding = "UTF-8", verbose = FALSE)
seoul <- seoul[str_detect(seoul@data$EMD_CD, "^11"),]
seoul <- spTransform(seoul, CRS("+proj=longlat +datum=NAD83"))

seoul_fty <- fortify(seoul, region="EMD_CD")
seoul_fty %>% ggplot(aes(x=long, y=lat, group=group)) + geom_polygon(fill='white', color='black') + theme_bw() + xlab("경도") + ylab("위도")
#ggsave(filename="seoul.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")


## set cellsize : set 100m(almost) distance for grid
cs <- c(0.00092, 0.0009)
grdpts <- makegrid(seoul, cellsize = cs)
spgrd <- SpatialPoints(grdpts, proj4string = CRS(proj4string(seoul)))
spgrdWithin <- SpatialPixels(spgrd[seoul,])

## match with shp data file
inshp <- over(spgrdWithin, seoul)

## make dataset
gridpoint <- spgrdWithin@coords
gridpoint_seoul <- cbind(gridpoint, as.character(inshp$EMD_CD))
gridpoint_seoul <- as.data.frame(gridpoint_seoul)
colnames(gridpoint_seoul) <- c("long", "lat", "code")

## preprocessing
gridpoint_seoul$long <- as.character(gridpoint_seoul$long)
gridpoint_seoul$lat <- as.character(gridpoint_seoul$lat)
gridpoint_seoul$code <- as.character(gridpoint_seoul$code)

gun_gu_code2 <- gun_gu_code
gun_gu_code2 <- gun_gu_code2 %>%
  dplyr::select(AD_CD, 법정동, 법정동코드)
gun_gu_code2$법정동코드 <- str_sub(gun_gu_code2$법정동코드, 1,8)
gun_gu_code2$code <- gun_gu_code2$법정동코드
gridpoint_seoul <- left_join(gridpoint_seoul, gun_gu_code2)

#gridpoint_seoul %>% ggplot(aes(x=long, y=lat))+ geom_point()
## make function
find_emd_circle <- function(long_rec, lat_rec){
  longcut <- gridpoint_seoul[which(gridpoint_seoul$long <= long_rec + 0.00566 &
                                 gridpoint_seoul$long >= long_rec -0.00566),]
  ### long 기준으로 0.00566정도는 좌우로 약 500m 거리의 지점을 의미합니다.
  latcut <- longcut[which(longcut$lat <= lat_rec + 0.00449 &
                          longcut$lat >= lat_rec - 0.00449),]
  ### lat 기준으로 0.00449정도는 상하로 약 500m 거리의 지점을 의미합니다.
  ### 즉, 역 기준으로 1km의 정사각형 구간으로 공간을 한정합니다.
  ### 이후 distHaversine 수식을 이용하여 500m 내에 포함되는 spot만 간추려냅니다.
  dist <- c()
  for(i in 1:nrow(latcut)){
    dist[i] <- distHaversine(c(as.numeric(latcut$long[i]),
                             as.numeric(latcut$lat[i])),
                             c(long_rec, lat_rec))
  }
  latcut_result <- latcut[which(dist <= 500),]
  result <- latcut_result %>% 
    dplyr::select(AD_CD) %>%
    group_by(AD_CD)%>%
    summarise(ratio=n()) %>%
    spread(AD_CD, ratio)
  gg <- ggplot(latcut_result, aes(x=long, y=lat, col=AD_CD)) + 
    geom_point()  + coord_fixed() + 
    scale_x_discrete(breaks=c(as.numeric(seq(min(latcut_result$long), 
                                  max(latcut_result$long), 0.0002)))) + 
    scale_y_discrete(breaks=c(as.numeric(seq(min(latcut_result$lat), 
                                  max(latcut_result$lat), 0.0002)))) +
    theme_bw()
  result_list <- list(table = result, plot = gg)
  result_list
}
```

```{r, echo=FALSE, fig.width=5, fig.height=3, fig.align='center'}
station_seoul[21,]
find_emd_circle(long_rec = station_seoul$long[21], 
                lat_rec = station_seoul$lat[21])

long_rec <- station_seoul$long[21]
lat_rec = station_seoul$lat[21]
longcut <- gridpoint_seoul[which(gridpoint_seoul$long <= long_rec + 0.00566 &
                                 gridpoint_seoul$long >= long_rec -0.00566),]
  ### long 기준으로 0.00566정도는 좌우로 약 500m 거리의 지점을 의미합니다.
latcut <- longcut[which(longcut$lat <= lat_rec + 0.00449 &
                        longcut$lat >= lat_rec - 0.00449),]
### lat 기준으로 0.00449정도는 상하로 약 500m 거리의 지점을 의미합니다.
### 즉, 역 기준으로 1km의 정사각형 구간으로 공간을 한정합니다.
### 이후 distHaversine 수식을 이용하여 500m 내에 포함되는 spot만 간추려냅니다.
dist <- c()
for(i in 1:nrow(latcut)){
  dist[i] <- distHaversine(c(as.numeric(latcut$long[i]),
                           as.numeric(latcut$lat[i])),
                           c(long_rec, lat_rec))
}
latcut_result <- latcut[which(dist <= 500),] %>%
  mutate(long = as.numeric(long), lat = as.numeric(lat))

result <- latcut_result %>% 
  dplyr::select(AD_CD) %>%
  group_by(AD_CD)%>%
  summarise(ratio=n()) %>%
  spread(AD_CD, ratio)
  
seoulstation_fty <- seoul_fty %>% 
  filter(long<=126.98, long > 126.965, lat <= 37.559, lat >37.549)  

ggplot() + 
  geom_polygon(aes(x=long, y=lat, group=group), fill='white', color='black', data=seoulstation_fty) + 
  geom_point(aes(x=126.9726, y=37.55465), size=3, col="red") +
  geom_point(data=latcut_result, aes(x=long, y=lat, col=AD_CD)) + theme_bw() + labs(col = "행정구역분류") + xlab("경도") + ylab("위도") + scale_fill_viridis_c() + scale_color_viridis_d() + coord_map()
#install.packages("mapproj")

#ggsave(filename="seoul_emd.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```
O

```{r echo=FALSE}
get_mean_grid <- data.frame(matrix(0, 302,26))
for(i in 1:302){
  result <- find_emd_circle(long_rec = station_seoul$long[i], 
                            lat_rec = station_seoul$lat[i])$table
  gugun_info_result <- gungu_info %>%
    filter(AD_CD %in% names(result)) %>%
    dplyr::select(-시도, -시군구, -행정구역명,-행정동,
                  -행정기관코드, -법정동, -행정기관코드,
                  -법정동코드, -관할지역, -`행정동 영문명칭`)
  gugun_info_result <- gugun_info_result %>%
    arrange(AD_CD) %>% dplyr::select(-AD_CD) %>% unique()
  resultset <- data.matrix(result) %*% data.matrix(gugun_info_result) / rowSums(result)
  resultset <- data.frame(resultset)
  get_mean_grid[i,] <- resultset
}

colnames(get_mean_grid) <- colnames(resultset)
result <- get_mean_grid
result <- cbind(station=station_seoul$station, result)

station_seoul_info <- station_seoul %>% 
  left_join(result) %>% separate(address, c("si", "address_gu", "dong")) %>% 
  dplyr::select(-si, -dong)

```

```{r load data hidden2, include=FALSE}
#save(file="../data/station_seoul_info.RData", station_seoul_info, gungu_info)
load(file="../data/station_seoul_info.RData")
#save(file="../data/fit_temp.RData", station_seoul_info, gungu_info, ridership_mean_infoset_train)
```

```{r}
line_available_list <- subway_data_G_DT %>%
  filter(Name %in% station_seoul_info$station) %>% 
  filter(!duplicated(Name)) %>% 
  mutate(tr_line = ifelse(Transfer !=0, paste0(Line, "|", Transfer), Line)) %>% 
  dplyr::select(Name, tr_line) 

line_available <- c()
for(i in 1:nrow(line_available_list)){
  line_available[i] <- nrow(str_locate_all(line_available_list$tr_line, "[|]")[[i]]) + 1
}

station_seoul_info$line_available <- line_available
```


#### 5.1.9 최종데이터 구조 

1> 302개 지하철역을 대상으로 41개의 주위정보 데이터

  * 지하철 위치정보 : lat, long, address_gu
  
  * 500m 반경 시설정보 : market_store, school, academy, cultural_facility, attraction, hospital, bus_stop, line_available
  
  * 4가지 용도지역 점수 : usz_sang, usz_ju, usz_gong, usz_etc
  
  * 가구부문 : avg_gagu_ppl, gagu_gen1, gagu_gen2, gagu_gen3, gagu_alone, gagu_etc
  
  * 사업체부문 : cp_bnu_003, cp_bnu_006, cp_bnu_007, cp_bnu_008, cp_bnu_009, cp_bnu_010, cp_bnu_011, cp_bnu_012, cp_bnu_013,
  cp_bnu_014, cp_bnu_015, cp_bnu_016, cp_bnu_017, cp_bnu_018, cp_bnu_019
  
  * 인구부문 : youngage, teenage, middleage1, middleage2, oldage
  
```{r}
glimpse(station_seoul_info)
```

2> 4월 한달간 승/하차 데이터베이스

  - 이용객 개별 승하차 데이터 내 출발역/도착역을 기준으로 데이터셋 생성 
  
  - 역별 요일(일-토)/시간대(지하철운행시간)/승하차 인원 수의 평균값

```{r, preproc for station count func, eval=FALSE}
load(file="/home/students/kson/route_04.RData")

station_count <- function(station){
  station_count <- route_04 %>% 
    filter(up_Name==station|down_Name==station)
  station_count_up <- station_count %>% 
    filter(up_Name==station) %>% 
    group_by(Date, Time, up_Name) %>% 
    summarise(n = n()) %>% 
    mutate(key = "up") %>%
    dplyr::select(Date, Time, key, n) %>%
    as_tibble
  station_count_down <- station_count %>%
    filter(down_Name==station) %>% 
    group_by(Date, Time, down_Name) %>% 
    summarise(n = n()) %>%
    mutate(key = "down") %>% 
    dplyr::select(Date, Time, key, n) %>%
    as_tibble
  result <- rbind(station_count_up, station_count_down)
  colnames(result) <- c("Date", "Time", "key", station)
  result$Time <- ifelse(str_count(result$Time)==1,
                        paste0(0, result$Time), result$Time)
  return(result)
}

tot_station <- str_sort(unique(route_04$up_Name))

result <- station_count(tot_station[1])

for(i in 2:241){
  add <- station_count(tot_station[i])
  result <- result %>% full_join(add)
}

```

```{r}
#* 역별 날짜/시간대별 승/하차 카운트 계산
#* 역별 요일/시간대별 평균값으로 계산
load(file="../data/ridership_04.RData")
#ridership_04$key <- ifelse(ridership_04$key=="up", "on", "off")
#ridership_04 <- rename(ridership_04, on_off = key)
#save(file="../data/ridership_04.RData", ridership_04)
ridership_04[is.na(ridership_04)] <- 0


Date_format <- data.frame(Date=unique(ridership_04$Date),
Day=c(rep(c("Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat"),4), "Sun", "Mon"))

ridership_04_set <- ridership_04 %>% 
  gather(station, count, colnames(ridership_04)[-1:-3]) %>% 
  left_join(Date_format) 
#%>% group_by(Day, Time, on_off, station) %>% summarise(count=mean(count, na.rm=T) %>% ceiling)

ridership_mean_infoset <- ridership_04_set %>% 
  left_join(station_seoul_info) %>% 
  na.omit()

ridership_mean_infoset_train <- ridership_mean_infoset %>% 
  group_by(Day, Time, station, on_off) %>% 
  summarise(mean_count = mean(count)) %>%
  left_join(station_seoul_info) %>% ungroup %>% 
  mutate(Time = as.numeric(Time), Day = as.factor(Day), on_off = as.factor(on_off)) %>% 
  data.frame()

```


### 5.2 알고리즘을 이용한 승하차 수요 예측

이용객 개별 승하차 데이터는 1-8호선에 속한 지하철역만 포함하기에 강북횡단선 내 신설역을 포함한 서울시 내 지하철역 302개 중 222개의 승/하차 인원 수만 확인 가능하다. 따라서 222개의 지하철역에 대한 승/하차 인원 수를 통하여 나머지 80개 역에 대한 승/하차 값을 알고리즘을 통하여 예측한다.

#### 5.2.1 탐색적 자료분석 

탐색적자료분석은 승하차 인원수가 제공되는 강북횡단선 내 6개의 지하철역으로 진행한다.

```{r}
## 평균 카운트 // 요일별 시간대별 평균 승하차인원 수
ridership_mean_infoset %>% dplyr::select(-Date) %>% group_by(Day, Time, on_off) %>%
  summarise(mean_count=mean(count)) %>%
  mutate(on_off = factor(on_off, levels = c("on", "off"),
                         labels = c("승차", "하차"))) %>% 
  ggplot(aes(x=as.numeric(Time), y=mean_count)) + 
  geom_bar(stat="identity") + 
  facet_grid(factor(Day, levels=c("Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat"),
                    labels=c("일", "월", "화", "수", "목", "금", "토"))~on_off) +
  ylab("평균 이용객 수") + xlab("시간") + theme_bw()
# ggsave(filename="day_time.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

ridership_mean_infoset %>% group_by(Date, Day, on_off) %>%
  summarise(mean_count=sum(count)) %>% 
  group_by(Day, on_off) %>% summarise(mean_count = mean(mean_count)) %>% 
  ungroup %>% 
  mutate(Day = factor(Day, levels=c("Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat"),
                    labels=c("일", "월", "화", "수", "목", "금", "토")),
         on_off = factor(on_off, levels = c("on", "off"),
                         labels = c("승차", "하차"))) %>% 
  ggplot(aes(x=Day, y=mean_count)) + 
  geom_bar(stat="identity") + ylab("평균 이용객 수") + xlab("요일") + theme_bw() 

# ggsave(filename="day_count.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

ridership_mean_infoset_train_raw <- ridership_mean_infoset %>% 
  group_by(Day, Time, station, on_off) %>% 
  summarise(mean_count = mean(count)) %>% 
  left_join(station_seoul_info) %>% ungroup %>% 
  mutate(Time = as.numeric(Time), Day = as.factor(Day), on_off = as.factor(on_off))

ridership_mean_infoset_train_raw_log <- ridership_mean_infoset %>% 
  group_by(Day, Time, station, on_off) %>% 
  summarise(mean_count = mean(count)) %>% 
  left_join(station_seoul_info) %>% ungroup %>% 
  mutate(Time = as.numeric(Time), Day = as.factor(Day), on_off = as.factor(on_off)) %>%
  mutate(mean_count = log(mean_count + 1))


ridership_mean_infoset_train <- ridership_mean_infoset %>% 
  group_by(Day, Time, station, on_off) %>% 
  summarise(mean_count = mean(count)) %>% 
  left_join(station_seoul_info) %>% ungroup %>% 
  mutate(Time = as.numeric(Time), Day = as.factor(Day), on_off = as.factor(on_off)) %>% 
  dplyr::select(-station) %>%  data.frame()

ridership_mean_infoset_train_select <- ridership_mean_infoset_train %>% filter(Time == "8", Day=="Mon", on_off =="on") %>% mutate(key = "승차")
ridership_mean_infoset_train_select2 <- ridership_mean_infoset_train %>% filter(Time == "8", Day=="Mon", on_off =="off") %>% mutate(key = "하차")
ridership_mean_infoset_train_select3 <- ridership_mean_infoset_train %>% filter(Time == "18", Day=="Mon", on_off =="on") %>% mutate(key = "승차")
ridership_mean_infoset_train_select4 <- ridership_mean_infoset_train %>% filter(Time == "18", Day=="Mon", on_off =="off") %>% mutate(key = "하차")

ridership_mean_infoset_train_select_tot <-
  rbind(ridership_mean_infoset_train_select, ridership_mean_infoset_train_select2,
        ridership_mean_infoset_train_select3, ridership_mean_infoset_train_select4) %>% 
  mutate(type = factor(key, levels=c("승차", "하차")),
         Time2 = paste0(Time, "시"))

ggmap(get_map(location = c(127, 37.55047), zoom = 11)) + 
    geom_point(data=ridership_mean_infoset_train_select_tot, 
               aes(x=long, y=lat, col=mean_count), size = 0.5) + facet_grid(Time2~type) +
  labs(col="평균 이용객 수") + xlab("경도") + ylab("위도") + scale_color_viridis_c() +
  scale_x_continuous(breaks = c(126.85, 127, 127.15)) +
  scale_y_continuous(breaks = c(37.4, 37.55, 37.7))  + theme_bw() +
  theme(axis.text.x = element_text(angle = 90),
        strip.text = element_text(size=7), axis.title=element_text(size=7),
        legend.title = element_text(size=7),
        legend.text = element_text(size=7), 
        axis.text = element_text(size=7), 
        legend.key.size = unit(0.5, "cm"))

# ggsave(filename="monday_8.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

```




#### 5.2.2 랜덤포레스트
`predict_count_rf(day_choose, time_choose, on_off_choose)` 

랜덤포레스트 알고리즘을 적용한 함수를 제작하여 요일, 시간대 그리고 승/하차를 선택하면 그 시점의 이용객 승하차 데이터베이스를 통하여 수요값을 예측한다.

  - 요일 : Sun - Sat 중 선택

  - 시간대 : 00,01,02,04-23 중 선택

  - 승하차 : 승/하차 중 선택
  
여기서 2개의 하이퍼파라미터를 고려해주어야 한다. 이때 하이퍼 파라미터 선정 기준은 다음과 같다.

    1. `mtry`란 노드를 나눌때 있어서 고려하는 변수의 개수라고 이해하면 된다. 여기서 랜덤포레스트 회귀의 경우 통상 `mtry`를 사용한 변수의 1/3을 사용한다.

    2. `ntree`란 나무의 개수로 랜덤포레스트에서 500개의 개별 의사결정나무를 생성하고 비교할 때 사용된다.
    
```{r, eval=FALSE}
library(tidyverse)
library(caret)
library(randomForest)
load("/home/students/kson/data/fit_temp.RData")

ridership_mean_infoset_train <- ridership_mean_infoset_train %>% mutate(address_gu = factor(address_gu))

rf_fit <- randomForest(mean_count ~. ,
                       data = ridership_mean_infoset_train,
                       mtry=floor(44/3), ntree=200)

bagg_fit <- randomForest(mean_count ~. ,
                         data = ridership_mean_infoset_train,
                         mtry=44, ntree=200)

#save(file="../data/rf_fit.RData", rf_fit)

fitControl <- trainControl(method = "repeatedcv", number = 10, repeats = 1)
rf_fit <- train(mean_count ~ ., data = ridership_mean_infoset_train, method = "rf", trControl = fitControl, verbose = F)
```

```{r}
ridership_mean_infoset_train <- ridership_mean_infoset_train %>% mutate_if(is.character, as.factor)
station_predict <- setdiff(station_seoul_info$station, ridership_mean_infoset$station)
```

```{r, eval=FALSE}
library(tidyverse)
library(caret)
library(randomForest)
library(parallel)
library(doParallel)
library(gbm)

load("/home/students/kson/data/fit_temp.RData")
set.seed(1234)

ridership_mean_infoset_train <- ridership_mean_infoset_train %>% 
  mutate_if(is.character, as.factor) %>% mutate(mean_count = log(mean_count + 1))

fitControl <- trainControl(method = "cv", number = 5, trim = TRUE)
cart_Grid <- expand.grid(cp=c(0.001))
fit_cart <- train(mean_count~., data=ridership_mean_infoset_train, 
                  method = 'rpart', trControl=fitControl, metric='RMSE',
                  maximize=FALSE, tuneGrid = cart_Grid)

save(file="/home/students/kson/data/fit_cart_log.RData", fit_cart)

gbm_Grid <- expand.grid(n.trees = c(1500, 2000), 
                        interaction.depth = c(4, 5, 6),
                        shrinkage = c(0.01),
                        n.minobsinnode = 10)
fit_gbm <- train(mean_count~., data=ridership_mean_infoset_train,
                 method = 'gbm', trControl=fitControl, 
                 tuneGrid=gbm_Grid, metric='RMSE',maximize=FALSE)

gbm_Grid2 <- expand.grid(n.trees = c(1200), 
                        interaction.depth = c(4,5,6),
                        shrinkage = c(0.01, 0.05, 0.1),
                        n.minobsinnode = 10)
fit_gbm_grid <- train(mean_count~., data=ridership_mean_infoset_train,
                 method = 'gbm', trControl=fitControl, 
                 tuneGrid=gbm_Grid2, metric='RMSE',maximize=FALSE)


save(file="/home/students/kson/data/fit_gbm_log.RData", fit_gbm)

fit_treebag <- train(mean_count~., data=ridership_mean_infoset_train,
                 method = 'treebag', trControl=fitControl, nbagg = 500)

rf_Grid <- expand.grid(mtry = c(floor(44/3)))
fit_rf <- train(mean_count~., data=ridership_mean_infoset_train,
                method = 'rf', trControl=fitControl, ntree = 500,
                tuneGrid=rf_Grid,metric='RMSE')

save(file="/home/students/kson/data/fit_rf_log.RData", fit_rf)
```

### prediction interval for gbm model

################ interval ################

```{r}
#load(file="../data/fit_cart.RData")
load(file="../data/fit_gbm_log.RData")
#load(file="../data/fit_temp.RData")
library(caret)
library(gbm)

varImp(fit_gbm)$importance %>% 
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(desc(Overall)) %>%
  head(20) %>% 
  mutate(변수명 = forcats::fct_inorder(rowname ),
            중요도 = Overall) %>% ggplot() +
    geom_col(aes(x = 변수명, y = 중요도)) + coord_flip() +
    theme_bw()

#ggsave(filename="varimpplot_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

ridership_mean_infoset_train <- ridership_mean_infoset_train %>% 
  mutate_if(is.character, as.factor) %>% mutate(mean_count = log(mean_count + 1))
res <- ridership_mean_infoset_train$mean_count - predict(fit_gbm, ridership_mean_infoset_train)
data.frame(res, real = rnorm(70152, 0, 0.453)) %>% gather(key="key", value = "value") %>% ggplot(aes(x=value, fill=key)) + geom_histogram(bins=70) + 
  scale_x_continuous(limits = c(-2,  2)) + labs(x="예측오차", y="빈도") + theme_bw() 


data.frame(res) %>% ggplot(aes(x=res)) + geom_histogram(bins=60) + 
  scale_x_continuous(limits = c(-2,  2)) + labs(x="예측오차", y="빈도") + theme_bw() 

quantile(res, 0.025)
quantile(res, 0.975)
#ggsave(filename="residual_plot.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

```


```{r}
predict_count_gbm <- function(day_choose = "Fri", time_choose = "20", on_off_choose = "off"){
  station_predict <- setdiff(station_seoul_info$station,
                             ridership_mean_infoset$station)
  new_data <- station_seoul_info %>% 
    filter(station %in% station_predict) %>%
    dplyr::select(-station) %>% 
    mutate(Day = factor(day_choose, levels=levels(ridership_mean_infoset_train$Day)), 
           Time = time_choose, on_off = factor(on_off_choose, levels(ridership_mean_infoset_train$on_off))) %>% 
    mutate(Time = as.numeric(Time), on_off = as.factor(on_off)) %>% 
    dplyr::select(colnames(ridership_mean_infoset_train)[c(-4)])

  station_seoul_info %>% 
    filter(station %in% station_predict) %>% 
    mutate(count = predict(fit_gbm, new_data)) %>% 
    mutate(Day = day_choose, Time = time_choose, on_off = on_off_choose) %>% 
    mutate(Time = as.numeric(Time), on_off = as.factor(on_off)) %>% 
    rename(count =mean_count) %>% 
    rbind(ridership_mean_infoset_train %>% ungroup %>% 
            filter(Time == time_choose, Day == day_choose, on_off == on_off_choose) %>% 
            mutate(Time = as.numeric(Time), on_off = as.factor(on_off))) %>% 
    as_tibble()
}

predict_count_gbm(day_choose = "Fri", time_choose = "20", 
                  on_off_choose = "off") %>% dplyr::select(station, count)
```

### prediction interval for gbm model
```{r}
crit_t <- abs(qt(0.025, df = 70154-44))

predict_interval_gbm <- function(day_choose = "Fri", time_choose = "20", on_off_choose = "off"){
  station_predict <- setdiff(station_seoul_info$station,
                             ridership_mean_infoset$station)
  new_data <- station_seoul_info %>% 
    filter(station %in% station_predict) %>%
    dplyr::select(-station) %>% 
    mutate(Day = factor(day_choose, levels=levels(ridership_mean_infoset_train$Day)), 
           Time = time_choose, 
           on_off = factor(on_off_choose, levels(ridership_mean_infoset_train$on_off))) %>%
    mutate(Time = as.numeric(Time), on_off = as.factor(on_off),
           address_gu = as.factor(address_gu)) %>% 
    dplyr::select(colnames(ridership_mean_infoset_train_raw_log)[c(-3,-5)])

  result_data <- matrix(nrow = nrow(new_data), ncol=4) %>% data.frame()
  colnames(result_data) <- c("station", "predict_value", "lower_bound", "upper_bound")
  result_data$station <- station_predict
  for(i in 1:nrow(new_data)){
    x_0 <- new_data[i,]
    y_hat <- predict(fit_gbm, newdata = x_0)
    #upper <- y_hat + crit_t * 0.4353 
    #lower <- y_hat - crit_t * 0.4353 
    upper <- y_hat + 0.9214204
    lower <- y_hat - 0.8215813
    result_data[i,c(2,3,4)] <- c(y_hat, lower, upper)
  }
  station_seoul_info %>% 
    filter(station %in% station_predict) %>% 
    left_join(result_data) %>% 
    mutate(Day = day_choose, Time = time_choose, on_off = on_off_choose) %>% 
    mutate(Time = as.numeric(Time), on_off = as.factor(on_off)) %>% 
    dplyr::select(station, Day, Time, on_off, predict_value, lower_bound, upper_bound) %>% 
    rbind(ridership_mean_infoset_train_raw_log %>% ungroup %>%
            rename(predict_value=mean_count) %>% 
            filter(Time == time_choose, Day == day_choose, on_off == on_off_choose) %>% 
            mutate(Time = as.numeric(Time), on_off = as.factor(on_off),
                   lower_bound = NA, upper_bound = NA) %>% 
            dplyr::select(station, Day, Time, on_off, predict_value, lower_bound, upper_bound)) %>% 
    as_tibble()
}
```

### 5.3 몬테카를로 샘플링

* 강북횡단선이 포함된 80개의 지하철역에 대하여 예측된 승하차 수요를 통하여 몬테카를로 샘플링을 시행함

```{r}
on_fri_15 <- predict_interval_gbm(day_choose = "Fri", time_choose = "15", on_off_choose = "on") 
off_fri_15 <- predict_interval_gbm(day_choose = "Fri", time_choose = "15", on_off_choose = "off")
input_data <- on_fri_15

MC_sampling <- function(input_data, on_off_choose, type="mean"){
  result_generate <- list()
  nms_get <- setdiff(station_seoul_info$station, ridership_mean_infoset$station)
  input_data <- input_data %>% mutate(mean = ifelse(predict_value<0, 0, exp(predict_value)-1) %>% ceiling(),
                                      lower = ifelse(lower_bound<0, 0, exp(lower_bound)-1) %>% ceiling(),
                                      upper = ifelse(upper_bound<0, 0, exp(upper_bound)-1) %>% ceiling()) 
  for(i in 1:length(nms_get)){
    input_data %>% data.frame()
    nrow_i <- input_data %>% filter(station==nms_get[i]) %>%
      dplyr::select(type) %>% t() %>% as.numeric() %>% ceiling()
    if(nrow_i > 0){
      result_generate[[nms_get[i]]] <- data.frame(matrix(0, nrow_i, 3))
      colnames(result_generate[[nms_get[i]]]) <- c("time", on_off_choose, 'generate')
      result_generate[[nms_get[i]]]$time <- input_data$Time[1]
      result_generate[[nms_get[i]]][,on_off_choose] <- nms_get[i]
      tot_except_i <- sum(input_data[input_data$station != nms_get[i], "mean"])
      generate <- sample(x = input_data$station[input_data$station != nms_get[i]],
                         replace =TRUE, 
                         size = nrow_i, 
                         prob = (input_data[input_data$station != nms_get[i], "mean"]/tot_except_i) %>% t() %>% as.numeric())
      result_generate[[nms_get[i]]]$generate <- generate
    }
  }
  gen_result <- result_generate[[1]]
  if(length(result_generate)>=2){
    for(i in 2:length(result_generate)){
      gen_result <- rbind(gen_result, result_generate[[i]])
    }
  }
   
  if(on_off_choose=="on"){
    gen_result <- gen_result %>% rename(depart = on, arrival = generate)
  }else{
    gen_result <- gen_result %>% rename(depart = generate, arrival = off)
  }
  gen_result %>% mutate(set = paste0(depart, "-", arrival),
                        day = input_data$Day %>% unique) %>%
    group_by(time, day, depart, arrival, set) %>% summarise(count=n()) %>% ungroup()
}

on_Sun_0 <- predict_interval_gbm(day_choose = "Sun", time_choose = "7", on_off_choose = "on")
on_Sun_0 %>% MC_sampling("on", type="mean") %>% filter(depart == "국민대") %>% 
  dplyr::select(day, depart, arrival, time, count, set)%>% head() %>% kable("latex")

```

예측한 80개의 지하철역의 승하차 인원 수를 통하여 이동경로를 예측한다. 예를들어, 월요일 7시의 석계역에서 승차하는 인원이 800명이라면, 동시간대에 다른 지하철역들의 하차인원수를 통하여 전체 인원수를 나누어 확률을 계산한다. 이를 통하여 석계역에서 승차하는 인원의 목적지(하차역)을 확률에 기반하여 추출하는 것이다. 

### 5.4 구간 수요예측
  
강북횡단선이 추가된 최단경로 데이터베이스를 이용하여 18년 4월 한달 간 역별/시간대별 이동경로 수요 파악를 파악한다.
사용할 데이터는 2018년 4월 한달 동안의 이용객 개별 승하차 데이터이며 총 112,863,737건이 포함되어 있다.


#### 5.4.1 이동경로 데이터셋 

2018년 4월 한달간 1억건이 넘는 이용객의 경로에 대하여 동일한 승차역, 하차역 경로에 대한 데이터셋을 구축한다. 이때 일자별 승차역, 하차역, 시간대를 기준으로 경로의 합계를 통하여 제작하였다.

```{r, eval=FALSE}
subway_04_route <- readRDS(file="../data/subway_04_route.RDS")
# subway_04_route <- readRDS(file="line_G/data/subway_04_route.RDS")

subway_04_route <- ungroup(subway_04_route)
colnames(subway_04_route) <- iconv(colnames(subway_04_route), "utf8")

#subway_04_route <- subway_04_route %>% 
#  mutate(set = paste0(승차역명, "-", 하차역명),
#         set_reverse= paste0(하차역명, "-", 승차역명))
day <- c(rep(c("일", "월", "화", "수", "목", "금", "토"), 4), "일", "월")

subway_04_route <- data.frame(운행일자 = c(20180401:20180430), 요일 = day) %>% 
  right_join(subway_04_route)

colnames(subway_04_route) <- c("date", "day", "ride_on", "ride_off", "time", "count")

subway_04_route$time <- ifelse(str_length(subway_04_route$time)==1,
                               paste0("0", subway_04_route$time),
                               subway_04_route$time)

#saveRDS(file="../data/subway_04_route.RDS", subway_04_route)
```

```{r}
subway_04_route <- readRDS(file="../data/subway_04_route.RDS")
ss <- subway_04_route %>% head(10000)
ss %>% filter(ride_on != ride_off, time == "07") %>%
  mutate(time = as.numeric(time)) %>% head() %>% kable("latex")
```

#### 5.4.2 요일 단위 승-하차역명 시간대 평균 count계산

* subway_04_route_daymean : 요일/시간대별 `출발역-도착역` 경로 평균

이동경로 데이터셋에 대하여 요일별로 평균을 계산하여, 특정요일 특정시간대 하나의 승차역-하차역으로 이루어지는 이동경로에 대한 평균을 계산할 수 있었다.

```{r}
subway_04_route_daymean <- subway_04_route %>% 
  group_by(day, ride_on, ride_off, time) %>% 
  summarise(count = mean(count)) %>% 
  mutate(count = ceiling(count))
subway_04_route_daymean <- subway_04_route_daymean %>% 
  mutate(time = as.numeric(time))
```


#### 5.4.3 특정 시간대 기준 이동경로수 계산

* 강북횡단선이 반영된 최단경로 DB

* 특정요일, 특정시간대 평균 count 확인

* MC sampling 결과 포함 

```{r, echo=FALSE}
time_choose <- "15"
day_choose <- "Fri"

summarise_count_db <- function(day_choose, time_choose, type){
  route_choose <- as.data.table(subway_04_route_daymean)
  setkey(route_choose, day)
  route_choose_frist <- route_choose[day==day_choose,]
  setkey(route_choose_frist, time)
  route_choose_second <- route_choose_frist[time==time_choose,]
  route_choose_second <- route_choose_second %>% 
    mutate(set = paste0(ride_on, "-", ride_off)) %>% as_tibble()
  on_case <- predict_interval_gbm(day_choose = day_choose, 
                               time_choose = time_choose, 
                               on_off_choose = "on") %>% 
    MC_sampling(on_off_choose =  "on", type) %>% 
    dplyr::select(day, depart, arrival, time, count) %>%
    mutate(set = paste0(depart, "-", arrival)) %>% 
    rename(ride_on = depart, ride_off = arrival)
  off_case <- predict_interval_gbm(day_choose = day_choose, 
                                time_choose = time_choose, 
                                on_off_choose = "off") %>%
    MC_sampling( on_off_choose =  "off") %>% 
    dplyr::select(day, depart, arrival, time, count) %>% 
    mutate(set = paste0(depart, "-", arrival)) %>% 
    rename(ride_on = depart, ride_off = arrival)
  unit <- route_choose_second %>% rbind(on_case, off_case) %>% 
    left_join(shortestpath_db_G) %>%
    mutate_all(as.character) %>% 
    ungroup %>% group_by(time, from, to) %>% 
    summarise(count = sum(as.numeric(count))) %>% as_tibble()
  unit
}

route_tot <- function(day_choose, time_choose, type){
  route_choose <- as.data.table(subway_04_route_daymean)
  setkey(route_choose, day)
  route_choose_frist <- route_choose[day==day_choose,]
  setkey(route_choose_frist, time)
  route_choose_second <- route_choose_frist[time==time_choose,]
  route_choose_second <- route_choose_second %>% 
    mutate(set = paste0(ride_on, "-", ride_off)) %>% as_tibble()
  on_case <- predict_interval_gbm(day_choose = day_choose, 
                               time_choose = time_choose, 
                               on_off_choose = "on") %>% 
    MC_sampling(on_off_choose =  "on", type) %>% 
    dplyr::select(day, depart, arrival, time, count) %>%
    mutate(set = paste0(depart, "-", arrival)) %>% 
    rename(ride_on = depart, ride_off = arrival)
  off_case <- predict_interval_gbm(day_choose = day_choose, 
                                time_choose = time_choose, 
                                on_off_choose = "off") %>%
    MC_sampling(on_off_choose =  "off", type) %>% 
    dplyr::select(day, depart, arrival, time, count) %>% 
    mutate(set = paste0(depart, "-", arrival)) %>% 
    rename(ride_on = depart, ride_off = arrival)
  result <- route_choose_second %>% rbind(on_case, off_case) 
  result
}


summarise_count_db(day_choose="Fri", time_choose="15", type="mean") 
summarise_count_db(day_choose="Fri", time_choose="15", type="lower") 


# 구간번호 수 
summarise_count_db(day_choose="Wed", time_choose="7", type="mean") %>% 
  filter(! from == to)
```

#### 5.4.4 최종 구간 수요예측

지하철에 대한 수요라 하면, 우선적으로 역별 승하차 값이 고려될 것이다. 하지만 실제 지하철 운영에 있어서는 시간대별 또는 특정 구간별 지하철을 이용하는 사람의 수를 예측하는 것이 지하철 운행면에서 더 중요할 것이다. 따라서 추가적으로 지하철 이동 간 경유하는 지하철 구간 또한 지하철 수요를 예측한다.

1. 역별 승하차 수

2. 역 이동경유 횟수

`predict_demand_line(day_choose, time_choose, line_choose)` 

  - 요일 : Sun - Sat 중 선택

  - 시간대 : 00, 06-23 중 선택

  - 노선 : 지하철 네트워크 내 22개 노선 중 선택
  
```{r, echo=FALSE}
predict_demand_line <- function(day_choose, time_choose, line_choose, type) {
  line_c <- subway_data_G[[line_choose]]$Name
  pred_on <- predict_interval_gbm(day_choose = day_choose, 
                               time_choose = time_choose, on_off_choose = "on") %>% 
        mutate(mean = ifelse(predict_value<0, 0, exp(predict_value)-1) %>% ceiling(),
               lower = ifelse(lower_bound<0, 0, exp(lower_bound)-1) %>% ceiling(),
               upper = ifelse(upper_bound<0, 0, exp(upper_bound)-1) %>% ceiling()) %>% 
    dplyr::select(station, Day, Time, on_off, type) %>% rename(pred_on = type, on = on_off)
  pred_off <- predict_interval_gbm(day_choose = day_choose,
                                time_choose = time_choose, on_off_choose = "off") %>% 
        mutate(mean = ifelse(predict_value<0, 0, exp(predict_value)-1) %>% ceiling(),
               lower = ifelse(lower_bound<0, 0, exp(lower_bound)-1) %>% ceiling(),
               upper = ifelse(upper_bound<0, 0, exp(upper_bound)-1) %>% ceiling()) %>% 
    dplyr::select(station, Day, Time, on_off, type) %>% rename(pred_off = type, off = on_off)
  result_sum <- summarise_count_db(day_choose = day_choose, time_choose = time_choose, type)
  result_onoff <- pred_on %>% 
    left_join(pred_off, by=c("station", "Day", "Time")) %>%
    filter(station %in% line_c) %>% 
    mutate(day = day_choose, pred_on = ceiling(pred_on),
           pred_off = ceiling(pred_off)) %>% 
    dplyr::select(Day, Time, station, pred_on, pred_off) %>% 
    rename(day = Day, time = Time) %>% 
    mutate(pred_on = ifelse(pred_on < 0, 0, pred_on),
           pred_off = ifelse(pred_off < 0, 0, pred_off))
  result_path_sum <- result_sum %>% 
    filter(from %in% line_c, to %in% line_c) %>% 
    mutate(day = day_choose) %>% 
    dplyr::select(day, time, from, to, count) %>% 
    filter(from != to)
  list(on_off = result_onoff, path = result_path_sum)
}

predict_demand_line(day_choose="Mon", time_choose="7", line_choose="G", type="mean")
```

앞단계에서의 예측값을 이용하여 우선 다음 2개의 데이터셋을 구축하였다.

```{r, eval=FALSE}
day_choose_list <- c("Sun", "Mon", "Tue", "Wed","Thr", "Fri", "Sat")
time_choose_list <- c(0, 6:23)
type_choose <- c("lower", "mean", "upper")

predict_week <- list()
route_total <- list()
for(i in seq_along(day_choose_list)){
  for(j in seq_along(time_choose_list)){
    for(k in seq_along(type_choose)){
      predict_week[[paste0(day_choose_list[i], "-", time_choose_list[j],
                           "-", type_choose[k])]] <- 
        predict_demand_line(day_choose=day_choose_list[i],
                            time_choose=time_choose_list[j],
                            line_choose="G", type =type_choose[k]) 
      
      route_total[[paste0(day_choose_list[i], "-", time_choose_list[j],
                          "-", type_choose[k])]] <-
        route_tot(day_choose=day_choose_list[i],
                  time_choose=time_choose_list[j], type = type_choose[k]) %>% nrow()
    }
  }
}

### 이동경로 자료 
i <- j <- 1; type = "mean"
route_choose <- as.data.table(subway_04_route_daymean)
setkey(route_choose, day)
route_choose_frist <- route_choose[day==day_choose_list[i],]
setkey(route_choose_frist, time)
route_choose_frist$time <- as.numeric(route_choose_frist$time)
route_choose_second <- route_choose_frist[time== time_choose_list[j],]
route_choose_second %>% head() %>% kable("latex")

## 최종 이동경로 자료
route_tot(day_choose="Sun", time_choose="7", type="mean") %>%
  filter(ride_on != ride_off, ride_on=="국민대") %>% head() %>% kable("latex")

lower_list <- str_which(names(predict_week), pattern="lower")
mean_list <- str_which(names(predict_week), pattern="mean")
upper_list <- str_which(names(predict_week), pattern="upper")
predict_week_onoff_lower <- predict_week[[lower_list[1]]]$on_off
predict_week_path_lower <- predict_week[[lower_list[1]]]$path
predict_week_onoff_mean <- predict_week[[mean_list[1]]]$on_off
predict_week_path_mean <- predict_week[[mean_list[1]]]$path
predict_week_onoff_upper <- predict_week[[upper_list[1]]]$on_off
predict_week_path_upper <- predict_week[[upper_list[1]]]$path
for(i in 2:length(lower_list)){
  predict_week_onoff_lower <- rbind(predict_week_onoff_lower,
                                    predict_week[[lower_list[i]]]$on_off) %>% na.omit()
  predict_week_path_lower <- rbind(predict_week_path_lower, 
                                   predict_week[[lower_list[i]]]$path) %>% na.omit()
  predict_week_onoff_mean <- rbind(predict_week_onoff_mean, 
                                   predict_week[[mean_list[i]]]$on_off) %>% na.omit()
  predict_week_path_mean <- rbind(predict_week_path_mean, 
                                  predict_week[[mean_list[i]]]$path) %>% na.omit()
  predict_week_onoff_upper <- rbind(predict_week_onoff_upper, 
                                    predict_week[[upper_list[i]]]$on_off) %>% na.omit()
  predict_week_path_upper <- rbind(predict_week_path_upper, 
                                   predict_week[[upper_list[i]]]$path) %>% na.omit()
}


#save(file="../data/predict_week_pi.RData", predict_week_onoff_lower, predict_week_path_lower,      predict_week_onoff_mean, predict_week_path_mean, predict_week_onoff_upper, predict_week_path_upper)
```

```{r}
load(file="../data/predict_week_pi.RData")
```

predict_week_onoff : Sun 00시부터 Sat 23시까지 랜덤포레스트알고리즘을 이용한 강북횡단선 내 지하철역 승하차 예측값

predict_week_path : Sun 00시부터 Sat 23시까지의 데이터 기반 강북횡단선 내 구간 이동 경로 카운트(평균)


### 6. 결과비교

#### 6.1.1 요일별 구간 수요 예측 결과 

우선 구간별 계산된 결과는 역별 승/하차 결과값 또한 반영된 결과이므로 이를 고려하여 다음과 같이 1일 노선 수요을 계산한다.

1. 요일별 강북횡단선 내 지하철 역 예상 승하차 이용객수 합

```{r out.width="75%", fig.align="center"}
### 요일/시간대별 구간 수요 예시 테이블
predict_week_path_mean %>% filter(day=="Sun", time == "7")



onoff_daily_gather_mean <- predict_week_onoff_mean %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  group_by(day, station) %>% 
  mutate(pred_on = ifelse(pred_on <0, 0, pred_on),
         pred_off = ifelse(pred_off <0, 0, pred_off)) %>% 
  summarise(on_daily = sum(pred_on), 
            off_daily = sum(pred_off))  %>% 
  gather(key='on_off', value = 'count', on_daily,off_daily) %>% 
  mutate(type = "mean")

onoff_daily_gather_lower <- predict_week_onoff_lower %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  group_by(day, station) %>% 
  mutate(pred_on = ifelse(pred_on <0, 0, pred_on),
         pred_off = ifelse(pred_off <0, 0, pred_off)) %>% 
  summarise(on_daily = sum(pred_on), 
            off_daily = sum(pred_off))  %>% 
  gather(key='on_off', value = 'count', on_daily,off_daily) %>% 
  mutate(type = "lower")

onoff_daily_gather_upper <- predict_week_onoff_upper %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  group_by(day, station) %>% 
  mutate(pred_on = ifelse(pred_on <0, 0, pred_on),
         pred_off = ifelse(pred_off <0, 0, pred_off)) %>% 
  summarise(on_daily = sum(pred_on), 
            off_daily = sum(pred_off))  %>% 
  gather(key='on_off', value = 'count', on_daily,off_daily) %>% 
  mutate(type = "upper")

bind_rows(list(onoff_daily_gather_mean, onoff_daily_gather_lower,  onoff_daily_gather_upper)) %>%
  mutate(구분 = ifelse(station %in% c("청량리","월곡", "길음","정릉","홍제",
                                    "디지털미디어시티","등촌","목동"),
                     "기존", "신설")) %>% 
  filter(구분=="신설", type=="mean") %>% ungroup %>% 
  mutate(승하차 = ifelse(on_off=="on_daily", "승차", "하차")) %>% 
  mutate(day = factor(day, labels=c("일", "월","화", "수", "목", "금", "토")),
         type = factor(type, levels=c("mean", "lower", "upper"), 
                       labels=c("예측값", "하한", "상한"))) %>% 
  ggplot(aes(x=day, y= count))+#, fill=type, group=type)) + 
  #geom_line() +
  geom_bar(position="dodge", stat="identity") +#, col="white", fill="black") +
  coord_cartesian(ylim=c(0, 12000)) + 
  facet_grid(승하차~station, space="free") +
  ylab("평균 이용객 수") + xlab("요일") + labs(fill="구분") + 
  theme(strip.text = element_text(size=4), axis.title=element_text(size=7),
        axis.text = element_text(size=4), legend.title = element_text(size=4),
        legend.text = element_text(size=4), legend.key.size = unit(0.2, "cm"),
        legend.position = "bottom") + 
  scale_fill_viridis_d() + scale_color_viridis_d()
#ggsave(filename="on_off_lineG_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

```

길음, 종암사거리, 목동 순으로 역별 승하차 이용객수가 많게 예측되었다. 이는 역 주위정보가 반영된 결과이다.

#### 6.1.2 시간대별 역/요일/승/하차별 승하차 수요예측 결과

```{r out.width="75%", fig.align="center"}
onoff_mean <- predict_week_onoff_mean %>% 
  mutate(day=factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  gather(on_off, count, pred_on, pred_off) %>% 
  mutate(type="mean")

onoff_lower <- predict_week_onoff_lower %>% 
  mutate(day=factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  gather(on_off, count, pred_on, pred_off) %>% 
  mutate(type="lower")

onoff_upper <- predict_week_onoff_upper %>% 
  mutate(day=factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  gather(on_off, count, pred_on, pred_off) %>% 
  mutate(type="upper")

predict_week_onoff_gather <- bind_rows(list(onoff_mean, onoff_lower,  onoff_upper))

```

```{r}
predict_week_onoff_gather %>% 
  mutate(count = ifelse(count <0, 0, count)) %>% 
  mutate(구분 = ifelse(station %in% c("청량리","월곡", "길음","정릉","홍제",
                                    "디지털미디어시티","등촌","목동"),
                     "기존", "신설")) %>% 
  filter(구분=="신설") %>% ungroup %>% 
  mutate(day = factor(day, labels=c("일", "월","화", "수", "목", "금", "토")),
         on_off = ifelse(on_off == "pred_on", "승차", "하차"),
         type = factor(type, levels=c("mean", "lower", "upper"),
                       labels=c("예측값", "하한", "상한"))) %>% 
  filter(on_off == "승차", ! day %in% c("토", "일")) %>% 
  group_by(time, station, type) %>% summarise(count = mean(count)) %>% 
  ggplot(aes(x=time, y= count)) + 
  geom_line(aes(color = type)) + facet_grid(~station) +
  coord_cartesian(ylim=c(0, 3000)) +  theme_bw()  +
  ylab("평균 이용객 수") + xlab("승차 시간") + labs(col="구분") +
  theme(strip.text = element_text(size=4), axis.title=element_text(size=7),
        axis.text = element_text(size=5), legend.title = element_text(size=7),
        legend.text = element_text(size=7),
        legend.position = "bottom") + scale_fill_viridis_c() +
  scale_color_viridis_d() 
# ggsave(filename="on_time_lineG_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

predict_week_onoff_gather %>% 
  mutate(count = ifelse(count <0, 0, count)) %>% 
  mutate(구분 = ifelse(station %in% c("청량리","월곡", "길음","정릉","홍제",
                                    "디지털미디어시티","등촌","목동"),
                     "기존", "신설")) %>% 
  filter(구분=="신설") %>% ungroup %>% 
  mutate(day = factor(day, labels=c("일", "월","화", "수", "목", "금", "토")),
         on_off = ifelse(on_off == "pred_on", "승차", "하차"),
         type = factor(type, levels=c("mean", "lower", "upper"),
                       labels=c("예측값", "하한", "상한"))) %>% 
  filter(on_off == "하차", ! day %in% c("토", "일")) %>% 
  group_by(time, station, type) %>% summarise(count = mean(count)) %>% 
  ggplot(aes(x=time, y= count)) + geom_line(aes(color = type)) + facet_grid(~station) + 
  coord_cartesian(ylim=c(0, 3000)) +  theme_bw()  +
  ylab("평균 이용객 수") + xlab("하차 시간") + labs(col="구분") +
  theme(strip.text = element_text(size=4), axis.title=element_text(size=7),
        axis.text = element_text(size=5), legend.title = element_text(size=7),
        legend.text = element_text(size=7),
        legend.position = "bottom") + scale_fill_viridis_c() +
  scale_color_viridis_d() 
#ggsave(filename="off_time_lineG_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

#ggsave(filename="on_off_time_lineG.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```

#### 6.1.3 요일별 강북횡단선 내 지하철역 승/하차 인원 예측값

승차인원과 하차인원의 합을 통하여 강북횡단선을 이용하여 승/하차 하는 인원은 약 30만명이 될 것으로 보인다.
```{r, fig.align='center'}
onoff_lineG_lower <- predict_week_onoff_lower %>% 
  filter(! station %in% c("청량리", "월곡", "길음", "정릉",
                   "디지털미디어시티", "홍제", "등촌", "목동")) %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"),
                      labels=c("일", "월","화", "수", "목", "금", "토"))) %>% 
  mutate(pred_on = ifelse(pred_on <0, 0, pred_on),
         pred_off = ifelse(pred_off <0, 0, pred_off)) %>% 
  group_by(day) %>% 
  summarise(ride_on = sum(pred_on),
            ride_off = sum(pred_off)) 

########### 신설예정역 승하차 / 하한
onoff_lineG_lower %>% kable("latex")

onoff_lineG_upper <- predict_week_onoff_upper %>% 
  filter(! station %in% c("청량리", "월곡", "길음", "정릉",
                   "디지털미디어시티", "홍제", "등촌", "목동")) %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"),
                      labels=c("일", "월","화", "수", "목", "금", "토"))) %>% 
  mutate(pred_on = ifelse(pred_on <0, 0, pred_on),
         pred_off = ifelse(pred_off <0, 0, pred_off)) %>% 
  group_by(day) %>% 
  summarise(ride_on = sum(pred_on),
            ride_off = sum(pred_off)) 

########### 신설예정역 승하차 / 상한
onoff_lineG_upper %>% kable("latex")


onoff_lineG_mean <- predict_week_onoff_mean %>% 
  filter(! station %in% c("청량리", "월곡", "길음", "정릉",
                   "디지털미디어시티", "홍제", "등촌", "목동")) %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"),
                      labels=c("일", "월","화", "수", "목", "금", "토"))) %>% 
  mutate(pred_on = ifelse(pred_on <0, 0, pred_on),
         pred_off = ifelse(pred_off <0, 0, pred_off)) %>% 
  group_by(day) %>% 
  summarise(ride_on = sum(pred_on),
            ride_off = sum(pred_off)) 

########### 신설예정역 승하차 / 평균
onoff_lineG_mean %>% kable("latex")

```

#### 6.1.4 역 사이 구간 수요

* 이는 없는 노선이 생겼다는 가정하에서 나온 결과값으로 1-8호선 내 실제 지하철 이용객들의 이동경로를 최단경로 자료구조를 통하여 알아본 후 계산한 결과이다.

```{r out.width="80%", fig.align='center'}
#predict_week_path %>% head() %>% kable("latex")

predict_week_path %>% 
  mutate(section = paste0(from, "-", to),
         day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"))) %>% 
  filter(from!=to) %>% 
  group_by(day, section) %>% 
  summarise(total = sum(count)) %>% 
  group_by(day) %>% summarise(mean_tot = mean(total)) %>% 
  kable("latex")

# 수요예측
get_linedemand <- function(input_data){
pred_sec_count <- input_data %>% 
  mutate(from = factor(from, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                        "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                        "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                        "신등촌", "목동사거리", "목동")),
           to = factor(to, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                    "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                    "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                    "신등촌", "목동사거리", "목동")),
           from_rank = as.numeric(from), to_rank = as.numeric(to)) %>% 
  mutate(type= ifelse(from_rank > to_rank, "상행", "하행")) %>% 
  mutate(section = paste0(from, "-", to),
         day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"),
                      labels = c("일", "월", "화", "수", "목", "금", "토")),
         from_lev = as.numeric(from), to_lev = as.numeric(to)) %>% 
  filter(from!=to) %>% 
  group_by(day, type, section) %>% 
  summarise(total = sum(count))

inner_G <- pred_sec_count_mean$section %>% unique()
unner_G_db <- shortestpath_db_G %>% mutate(section=paste0(from, "-", to)) %>% 
  filter(section %in% inner_G)

on_route_G <- unner_G_db %>% separate(set, c("st", "end"), remove=FALSE) %>% 
  filter(st %in% c("청량리", "월곡", "길음", "정릉",
                   "디지털미디어시티", "홍제", "등촌", "목동")) 

off_route_G <- unner_G_db %>% separate(set, c("st", "end"), remove=FALSE) %>% 
  filter(end %in% c("청량리", "월곡", "길음", "정릉",
                   "디지털미디어시티", "홍제", "등촌", "목동")) 

########### 환승역들 승하차 인원수 
route_choose <- as.data.table(subway_04_route_daymean)
route_choose_sum <- route_choose %>% 
  mutate(set = paste0(ride_on, "-", ride_off)) %>% 
  group_by(day, set) %>% summarise(sum_count = sum(count)) %>% 
  as.data.table()
setkey(route_choose_sum, set)
transfer_lineG <- route_choose_sum[set %in% unique(on_route_G$set), ] %>% group_by(day) %>% 
  summarise(on_count = sum(sum_count)) %>% cbind(
route_choose_sum[set %in% unique(off_route_G$set), ] %>% group_by(day) %>% 
  summarise(off_count = sum(sum_count)) %>% 
  ungroup %>% dplyr::select(-day)
) %>% as_tibble()
transfer_lineG$day <- c("금", "목", "수", "월", "일", "토", "화")

return(transfer_lineG)
}

tot_onoff_lower <- get_linedemand(predict_week_path_lower) %>% 
  merge(onoff_lineG_lower) %>%
  mutate(on = on_count + ride_on,
         off = off_count + ride_off,
         tot = on + off,
         day = factor(day, levels=c("일","월","화","수","목","금","토"))) %>%
  arrange(day)

tot_onoff_mean <- get_linedemand(predict_week_path_mean) %>% 
  merge(onoff_lineG_mean) %>%
  mutate(on = on_count + ride_on,
         off = off_count + ride_off,
         tot = on + off,
         day = factor(day, levels=c("일","월","화","수","목","금","토"))) %>%
  arrange(day)

tot_onoff_upper <- get_linedemand(predict_week_path_upper) %>% 
  merge(onoff_lineG_upper) %>%
  mutate(on = on_count + ride_on,
         off = off_count + ride_off,
         tot = on + off,
         day = factor(day, levels=c("일","월","화","수","목","금","토"))) %>%
  arrange(day)

inner_outer_G <- unner_G_db %>% separate(set, c("st", "end"), remove=FALSE) %>% 
  filter(! st %in% line_G$Name, ! end %in% line_G$Name)
### 1604개의 환승경로로 이동하는 경우 
inner_outer_G$set %>% unique %>% length()

summarise_count_G <- function(day_choose, time_choose, type){
  route_choose <- as.data.table(subway_04_route_daymean)
  setkey(route_choose, day)
  route_choose_frist <- route_choose[day==day_choose,]
  setkey(route_choose_frist, time)
  route_choose_second <- route_choose_frist[time==time_choose,]
  route_choose_second <- route_choose_second %>% 
    mutate(set = paste0(ride_on, "-", ride_off)) %>% as_tibble()
  on_case <- predict_interval_gbm(day_choose = day_choose, 
                               time_choose = time_choose, 
                               on_off_choose = "on") %>% 
    MC_sampling(on_off_choose =  "on", type) %>% 
    dplyr::select(day, depart, arrival, time, count) %>%
    mutate(set = paste0(depart, "-", arrival)) %>% 
    rename(ride_on = depart, ride_off = arrival)
  off_case <- predict_interval_gbm(day_choose = day_choose, 
                                time_choose = time_choose, 
                                on_off_choose = "off") %>%
    MC_sampling( on_off_choose =  "off") %>% 
    dplyr::select(day, depart, arrival, time, count) %>% 
    mutate(set = paste0(depart, "-", arrival)) %>% 
    rename(ride_on = depart, ride_off = arrival)
  unit <- route_choose_second %>% rbind(on_case, off_case) %>% 
    as.data.table()
  setkey(unit, set)
  unit[set %in% unique(inner_outer_G$set)] %>% 
    group_by(day, set) %>% summarise(sum_count = sum(count))
}

day_choose_list <- c("Sun", "Mon", "Tue", "Wed","Thr", "Fri", "Sat")
time_choose_list <- c(0, 6:23)
type_choose
tot_day_list_sec <- list()
for(i in seq_along(day_choose_list)){
  for(j in 1:length(time_choose_list)){
    for(k in 1:length(type_choose)){
      tot_day_list_sec[[paste0(day_choose_list[i], "-", time_choose_list[j],
                           "-", type_choose[k])]] <-
        summarise_count_G(day_choose=day_choose_list[i], 
                          time_choose = time_choose_list[j],
                          type = type_choose[k]) %>%
        summarise(tot_sum = sum(sum_count))
    }
  }
}


#sapply(1:398, function(x){tot_day_list_sec[[x]]$day})
tot_day_list_sec[[1]]$day <- "Sun"
tot_day_list_sec[[2]]$day <- "Sun"
daily_tot <- data.frame(matrix(0, 19, 7))
colnames(daily_tot) <- c("일", "월", "화", "수","목", "금", "토")
daily_tot_lower <- daily_tot_mean <- daily_tot_upper <- daily_tot

for(k in 1:19){
  daily_tot_lower[k,1] <- tot_day_list_sec[[k]]$tot_sum
  daily_tot_lower[k,2] <- tot_day_list_sec[[(k+57)]]$tot_sum
  daily_tot_lower[k,3] <- tot_day_list_sec[[(k+114)]]$tot_sum
  daily_tot_lower[k,4] <- tot_day_list_sec[[(k+171)]]$tot_sum
  daily_tot_lower[k,5] <- tot_day_list_sec[[(k+228)]]$tot_sum
  daily_tot_lower[k,6] <- tot_day_list_sec[[(k+285)]]$tot_sum
  daily_tot_lower[k,7] <- tot_day_list_sec[[(k+342)]]$tot_sum
  daily_tot_mean[k,1] <- tot_day_list_sec[[k+1]]$tot_sum
  daily_tot_mean[k,2] <- tot_day_list_sec[[(k+57+1)]]$tot_sum
  daily_tot_mean[k,3] <- tot_day_list_sec[[(k+114+1)]]$tot_sum
  daily_tot_mean[k,4] <- tot_day_list_sec[[(k+171+1)]]$tot_sum
  daily_tot_mean[k,5] <- tot_day_list_sec[[(k+228+1)]]$tot_sum
  daily_tot_mean[k,6] <- tot_day_list_sec[[(k+285+1)]]$tot_sum
  daily_tot_mean[k,7] <- tot_day_list_sec[[(k+342+1)]]$tot_sum
  daily_tot_upper[k,1] <- tot_day_list_sec[[k+2]]$tot_sum
  daily_tot_upper[k,2] <- tot_day_list_sec[[(k+57+2)]]$tot_sum
  daily_tot_upper[k,3] <- tot_day_list_sec[[(k+114+2)]]$tot_sum
  daily_tot_upper[k,4] <- tot_day_list_sec[[(k+171+2)]]$tot_sum
  daily_tot_upper[k,5] <- tot_day_list_sec[[(k+228+2)]]$tot_sum
  daily_tot_upper[k,6] <- tot_day_list_sec[[(k+285+2)]]$tot_sum
  daily_tot_upper[k,7] <- tot_day_list_sec[[(k+342+2)]]$tot_sum
}

inner_result_lower <- daily_tot_lower %>% mutate_all(as.numeric) %>% colSums()
inner_result_mean <- daily_tot_mean %>% mutate_all(as.numeric) %>% colSums()
inner_result_upper <- daily_tot_upper %>% mutate_all(as.numeric) %>% colSums()

data.frame(day = daily_tot %>% names(), inner_count = inner_result_lower) %>% 
  left_join(tot_onoff_lower) %>% mutate(final = tot + inner_count)

data.frame(day = daily_tot %>% names(), inner_count = inner_result_mean) %>% 
  left_join(tot_onoff_mean) %>% mutate(final = tot + inner_count)

data.frame(day = daily_tot %>% names(), inner_count = inner_result_upper) %>% 
  left_join(tot_onoff_upper) %>% mutate(final = tot + inner_count)

```

```{r out.width="80%", fig.align='center'}
predict_week_path_longlat_mean <- subway_data_G[["G"]][,c("Name", "long", "lat")] %>% 
  rename(from = Name) %>% 
  right_join(predict_week_path_mean) %>% 
  rename(from_long = long, from_lat = lat,
         Name = to) %>%
  left_join(subway_data_G[["G"]][,c("Name", "long", "lat")]) %>% 
  rename(to = Name, to_long = long, to_lat = lat) 
predict_week_path_longlat_mean <- predict_week_path_longlat_mean %>% 
    mutate(from = factor(from, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                        "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                        "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                        "신등촌", "목동사거리", "목동")),
           to = factor(to, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                    "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                    "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                    "신등촌", "목동사거리", "목동")),
           from_rank = as.numeric(from), to_rank = as.numeric(to))

predict_week_path_longlat_lower <- subway_data_G[["G"]][,c("Name", "long", "lat")] %>% 
  rename(from = Name) %>% 
  right_join(predict_week_path_lower) %>% 
  rename(from_long = long, from_lat = lat,
         Name = to) %>%
  left_join(subway_data_G[["G"]][,c("Name", "long", "lat")]) %>% 
  rename(to = Name, to_long = long, to_lat = lat) 
predict_week_path_longlat_lower <- predict_week_path_longlat_lower %>% 
    mutate(from = factor(from, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                        "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                        "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                        "신등촌", "목동사거리", "목동")),
           to = factor(to, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                    "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                    "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                    "신등촌", "목동사거리", "목동")),
           from_rank = as.numeric(from), to_rank = as.numeric(to))

predict_week_path_longlat_upper <- subway_data_G[["G"]][,c("Name", "long", "lat")] %>% 
  rename(from = Name) %>% 
  right_join(predict_week_path_upper) %>% 
  rename(from_long = long, from_lat = lat,
         Name = to) %>%
  left_join(subway_data_G[["G"]][,c("Name", "long", "lat")]) %>% 
  rename(to = Name, to_long = long, to_lat = lat) 
predict_week_path_longlat_upper <- predict_week_path_longlat_upper %>% 
    mutate(from = factor(from, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                        "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                        "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                        "신등촌", "목동사거리", "목동")),
           to = factor(to, levels=c("청량리", "홍릉", "월곡", "종암사거리", "길음", "정릉", 
                                    "국민대", "평창동", "상명대입구", "홍제", "서대문구청", 
                                    "명지대", "남가좌", "디지털미디어시티", "상암", "등촌",
                                    "신등촌", "목동사거리", "목동")),
           from_rank = as.numeric(from), to_rank = as.numeric(to))
path_count_G <- function(time_choose, day_choose, on_off){
  predict_week_path_longlat_key <- predict_week_path_longlat %>% 
      filter(from_rank>to_rank)
  if(on_off == "on"){
    predict_week_path_longlat_key <- predict_week_path_longlat %>% 
      filter(from_rank<to_rank)
  }
  from_set <- predict_week_path_longlat_key %>%
    mutate(set = paste0(from, "-", to)) %>% 
    filter(time==time_choose, day == day_choose) %>% 
    dplyr::select(time, day, set, from, from_long, from_lat, count)
  from_set$key <- "from"
  to_set <- predict_week_path_longlat_key %>%
    mutate(set = paste0(from, "-", to)) %>% 
    filter(time==time_choose, day == day_choose) %>% 
    dplyr::select(time, day, set, to, to_long, to_lat, count)
  to_set$key <- "to"  
  colnames(from_set) <- colnames(to_set) <- c("time", "day", "set", "station",
                                              "long", "lat", "count", "key")
  from_to_path_set <- rbind(from_set, to_set)
  ggmap(get_map(location = c(126.9534, 37.58047), zoom = 12)) + 
    geom_path(data=from_to_path_set, aes(x=long, y=lat, col=count, group=set), size=4) +
    scale_color_gradient(low="yellow", high="red") +
    ggtitle(paste("each count of section", "in", time_choose, day_choose, on_off))
}

```

* 특정 요일/시간대 구간 카운트 시각화 예시

```{r out.width="75%", fig.align="center", echo=FALSE}

get_fromto_section <- function(input_data){
predict_week_path_longlat_key <- input_data %>% 
      mutate(type = ifelse(from_rank>to_rank, "상행", "하행"))
from_set <- predict_week_path_longlat_key %>%
  mutate(set = paste0(from, "-", to)) %>% 
  dplyr::select(time, day, set, from, from_long, from_lat, count, type)
from_set$key <- "from"
to_set <- predict_week_path_longlat_key %>%
  mutate(set = paste0(from, "-", to)) %>% 
  dplyr::select(time, day, set, to, to_long, to_lat, count, type)
to_set$key <- "to"  
colnames(from_set) <- colnames(to_set) <- c("time", "day", "set", "station",
                                            "long", "lat", "count", "type", "key")
from_to_path_set <- rbind(from_set, to_set)

from_to_path_set_select <- from_to_path_set %>% filter(time == "15", day=="Mon")
from_to_path_set_select2 <- from_to_path_set %>% filter(time == "18", day=="Mon")

from_to_path_set_tot <- rbind(from_to_path_set_select, from_to_path_set_select2) %>% 
  mutate(time2 = paste0(time, "시"))
from_to_path_set_tot
}


ggmap(get_map(location = c(126.95, 37.58), zoom = 12)) + 
   geom_path(data=get_fromto_section(predict_week_path_longlat_mean), 
             aes(x=long, y=lat, col=count, group=set), size=2) +
  scale_x_continuous(breaks = c(126.8, 126.9, 127)) +
  scale_y_continuous(breaks = c(37.5, 37.55, 37.6)) + 
  facet_grid(time2~type) +
  labs(col="평균 이용객 수") + xlab("경도") + ylab("위도") +
  scale_fill_viridis_c() + scale_color_viridis_c() + theme_bw() +
  theme(strip.text = element_text(size=7), axis.title=element_text(size=7),
        axis.text = element_text(size=7), legend.title = element_text(size=7),
        legend.text = element_text(size=7), legend.key.size = unit(0.5, "cm"),
        axis.text.x = element_text(angle = 90))
#ggsave(filename="section_demand_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```

```{r}
predict_week_path_longlat_upper %>% 
  mutate(type = ifelse(from_rank>to_rank, "상행", "하행")) %>% 
  filter(type == "상행") %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"),
                      labels=c("일", "월","화", "수", "목", "금", "토"))) %>% 
  mutate(구간 = paste0(from, "-", to),
         time = as.numeric(time)) %>% 
  ggplot(aes(x=time, y=count, col=구간, group=구간)) +
  geom_line() + facet_grid(~day) + theme_bw() + 
  ylab("이용객 수") + xlab("시간") +
  theme(strip.text = element_text(size=5), axis.title=element_text(size=7),
        axis.text = element_text(size=5), legend.title = element_text(size=4),
        legend.text = element_text(size=5), legend.key.size = unit(0.5, "cm"),
        legend.position = "bottom") + 
  scale_fill_viridis_c() + scale_color_viridis_d()
#ggsave(filename="up_section_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
#ggsave(filename="up_section_log_upper.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
#ggsave(filename="up_section_log_lower.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")

predict_week_path_longlat_upper %>% 
  mutate(type = ifelse(from_rank>to_rank, "상행", "하행")) %>% 
  filter(type == "하행") %>% 
  mutate(day = factor(day, levels=c("Sun","Mon","Tue","Wed","Thr","Fri","Sat"),
                      labels=c("일", "월","화", "수", "목", "금", "토"))) %>% 
  mutate(구간 = paste0(from, "-", to),
         time = as.numeric(time)) %>% 
  ggplot(aes(x=time, y=count, col=구간, group=구간)) +
  geom_line() + facet_grid(~day) + theme_bw() + 
  ylab("이용객 수") + xlab("시간") +
  theme(strip.text = element_text(size=5), axis.title=element_text(size=7),
        axis.text = element_text(size=5), legend.title = element_text(size=4),
        legend.text = element_text(size=5), legend.key.size = unit(0.2, "cm"),
        legend.position = "bottom") + 
  scale_fill_viridis_c() + scale_color_viridis_d()
#ggsave(filename="down_section_log.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
#ggsave(filename="down_section_log_lower.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
#ggsave(filename="down_section_log_upper.pdf", path="D:/workspace/seoulsubway_G/line_G/figure")
```



  
